<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>simple.mvc.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Controller.html">Controller</a></li>
                                <li><a href="../classes/getSetHtml.html">getSetHtml</a></li>
                                <li><a href="../classes/List.html">List</a></li>
                                <li><a href="../classes/ModelView.html">ModelView</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/JSON.html">JSON</a></li>
                                <li><a href="../modules/MVC.html">MVC</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: simple.mvc.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
// ==========================================================================
// Project:     Simple.mvc.js - A lightweight MVC library for UI binding.
// Copyright:   (c)2012-2016 Benjamin Hammer (hammerbenjamin@gmail.com)
// Version:     2016.2.24
// Licence:     Licensed under MIT license (see LICENCE.MD)
// Description:
//     * README.MD
//     * http://github.com/bnji/simplemvc
//     * http://hammerbenjamin.com/simplemvc
// ==========================================================================
/**
 *     Design rules:
 *     1) Capitalization
 *        Internal methods (except .toArray()) should have the
 *        first letter capitalized, so it&#x27;s possible to
 *        distinguish between internal JavaScript methods and
 *        Simple.mvc ModelView object. methods.
 *
 *     2) Bracket vs Dot notation
 *        Older versions of IE don&#x27;t accept the use of
 *        accessing a an object&#x27;s property using dot-
 *        notation (obj.propertyName). However,
 *        accessing the property using bracket notation
 *        will work (obj[&#x27;propertyName&#x27;]).
 *
 *
 * @module MVC
 * @main MVC
 */
var MVC = {
  /**
   * KeyCheck
   *
   * A friendly way to check which key was used.
   *
   * @method KeyCheck
   * @param {Object} e Event
   * @param {String} n Name of the key to check against (e.g. &#x27;enter&#x27;, &#x27;escape&#x27;)
   */
  KeyCheck : function(e, n) {
    if(e.keyCode === 13 &amp;&amp; (n === &#x27;enter&#x27; || n === &#x27;return&#x27;)) {
      return true;
    } else if(e.keyCode === 27 &amp;&amp; (n === &#x27;escape&#x27; || n === &#x27;esc&#x27;)) {
      return true;
    }
    return false;
  },
  /**
   * List
   *
   * A more human way of handling array&#x27;s in JavaScript. It provides some extra
   * methods for manipulating an array, which makes it more easy and semantic
   * such as when e.g. adding and removing elements using .Add() and .Remove().
   *
   * @class List
   * @param {Object} An array (is optional)
   */
  List : function(array) {
    //If &#x27;array&#x27; hasn&#x27;t been specified, then create an empty Array.
    if(array === null || array === undefined) {
      array = [];
    }
    //If the input array is an object literal, then convert it to an array
    else if(!$.isArray(array) &amp;&amp; typeof(array) === &#x27;object&#x27;) {
      //array = $.makeArray(array);
      var newArray = [], i = 0;
      $.each(array, function(k, v) {
        if(typeof v !== &#x27;function&#x27;) {
          newArray[i] = v;
          i++;
        }
      });
      array = newArray;
    }

    /**
     * Size
     *
     * Return the length of the array (same as array.length);
     * @return {Number} The length of the array.
     */
    array.Size = function() {
      return array.length;
    };

    /**
     * Add
     *
     * Add a new element - It&#x27;s more semantic to use .Add() instead of .push().
     *
     * @method Add
     * @param {Object} An element.
     * @return {Array} The array.
     */
    array.Add = function(element) {
      array.push(element);
      return array;
    };

    /**
     * Get
     *
     * Get an element from the array.
     *
     * @method Get
     * @param {Integer} A key.
     * @return {Object} An object from the array.
     */
    array.Get = function(key) {
      return array[key];
    };

    /**
     * Find
     *
     * Find an element in the array. Returns null, if nothing is found.
     *
     * @method GetById
     * @param {Object} A key.
     * @param {Object} A value to search for.
     * @return {Object} An object from the array.
     */
    array.Find = function(key, value) {
      var result = null;
      $.each(array, function(k,v) {
        if(v[key] === value) {
          result = v;
          return false;
        }
      });
      return result;
    };

    /**
     * Remove
     *
     * Remove an element (if found) from the array.
     *
     * @method Remove
     * @param {Object} An element.
     */
    array.Remove = function(element) {
      // More about deleting elements from an array in JavaScript:
      // http://stackoverflow.com/questions/500606/javascript-array-delete-elements
      // indexOf breaks in IE &lt; 9!
      // var i = array.indexOf(element);
      // Solution:
      var i = $.inArray(element, array);
      if(i !== -1) {
        array.splice(i, 1);
        return true;
      }
      return false;
    };

    /**
     * RemoveAt
     *
     * Remove an element at index (if found) from the array.
     *
     * @method RemoveAt
     * @param {Integer} Index.
     */
    array.RemoveAt = function(index) {
      return this.Remove(this.Get(index));
    };

    /**
     * Contains
     *
     * Check if the specified element is in the list
     *
     * @method Contains
     * @param {Object} An element.
     */
    array.Contains = function(element) {
      return $.inArray(element, array) !== -1;
    };

    /**
     * Clear
     *
     * Remove all the elements from the array.
     *
     * @method Clear
     */
    array.Clear = function() {
      //array.splice(0, array.length);
      array = [];
    };
    return array;
  },
  /**
   * Controller which handles the logic, such as saving, updating or deleting
   * the object.
   *
   * Defintion
   * Controller: The controller interprets the mouse and keyboard inputs from the user,
   * informing the model and/or the view to change as appropriate.
   * Source: http://bit.ly/fQnaJI
   *
   * For the time being the Controller class doesn&#x27;t do much more than returning
   * the same data as entered (JSON) object literal. Still this is by design, as
   * there is a possibility for the &#x27;controller&#x27; to do more than this &#x27;stuff&#x27;
   * (handling more than returning data) in the future.
   *
   *
   * @class Controller
   * @constructor
   */
  Controller : function(data) {
    return data;
  }
  //ModelView has code is now written as a jQuery plugin: simple.mvc.jquery.js
};

/**
 * ModelView written as a jQuery plugin (most basic form of plugin authoring).
 *
 * Reasons for this:
 *  Several... but mainly just trying to make it easier for anyone who already
 *  knows jQuery gettings started using Simple.mvc.
 *
 * For more information on different jQuery plugin design patterns:
 * https://github.com/addyosmani/jquery-plugin-patterns/tree/master/patterns
 *
 */
(function( $ ) {
  $.fn.extend({
    /**
     * ModelView
     *
     * Definition:
     * Model: The model manages the behavior and data of the application domain,
     * responds to requests for information about its state (usually from the view),
     * and responds to instructions to change state (usually from the controller).
     * View: The view manages the display of information.
     * Source: http://bit.ly/fQnaJI
     *
     * ModelView creates the glue which binds the UI(View) with the Backend code
     * functionality of the program. It keeps the View synchronized with the &#x27;Model&#x27;.
     *
     * ModelView creates a new object with data and settings. The data and
     * settings are (JSON) object literals and merged and returned after all the
     * internal setup is done.
     * The ModelView contains all the information about the object, which keeps
     * the View synchronized with the Model and vice versa.
     *
     * @class ModelView
     * @constructor
     *
     * @param {Object} $object   Model data
     * @param {Object} $settings Config &amp; view input events
     * @param {Object} $methods  Custom user defined methods/functions
    */
    ModelView: function( $object, $settings, $methods ) {
      var computedProperties = [];
      $this = $(this);
      var viewId = &#x27;#&#x27;+$this.attr(&#x27;id&#x27;);
      // Make sure that the object data always exists. Only require &#x27;viewId&#x27;
      if(!$object) {
        $object = {};
      }
      else {
        $object = $.extend({}, true, $object);
      }
      // Make sure that the object methods always exists. Only require &#x27;viewId&#x27;
      if(!$methods) {
        $methods = {};
      }
      else {
        $object = $.extend({}, true, $object, $methods);
      }
      // Make sure that the settings always exist and with certain properties.
      if(!$settings) {
        $settings = {};
      }
      var datasrc = $settings[&#x27;datasrc&#x27;];
      var clone = $settings[&#x27;clone&#x27;];
      // If cloning-&#x27;functionality&#x27; is implemented:
      if(clone !== undefined) {
        // Set the clone template to be the view id
        clone[&#x27;template&#x27;] = viewId;
        // Update the view id with the new clone id
        if(clone[&#x27;id&#x27;] === undefined) {
          viewId = &quot;#&quot; + $.now();
        }
        else {
          // Make sure it&#x27;s a string
          viewId = &#x27;&#x27; + clone[&#x27;id&#x27;];
        }
        // If the clone view id has hashtag specified
        if(viewId.substring(0, 1) === &#x27;#&#x27;) {
          viewIdNoHash = viewId.substring(1, viewId.length);
        }
        // If there&#x27;s no hashtag
        else {
          viewIdNoHash = viewId;
        }
        // Clone the source and update the viewId
        var withDataAndEvents = $settings[&#x27;clone&#x27;][&#x27;withDataAndEvents&#x27;];
        withDataAndEvents = withDataAndEvents !== undefined ? withDataAndEvents : false;
        $settings[&#x27;clone&#x27;][&#x27;withDataAndEvents&#x27;] = withDataAndEvents;
        var element = $($(clone[&#x27;template&#x27;]).clone(withDataAndEvents)).attr(&#x27;id&#x27;, viewIdNoHash);
        // datasrc property to the settings, as it should be possible to create a
        // ModelView without any data, but solely relies on receiving updated
        // values from another view!
        // If the datasrc isn&#x27;t specified, then use the viewId as datasrc.
        datasrc = datasrc !== undefined ? datasrc : viewId;
        // Update the datasrc with the new view id
        $(element).find(&#x27;[datasrc=&quot;&quot;]&#x27;).attr(&#x27;datasrc&#x27;, datasrc);
        // If the template originally was hidden using &#x27;display: none;&#x27; - make it visible
        // Append the copy to the target
        // Execute the append callback function which normally would involve
        // appending and making it visible (If the template originally was hidden using &#x27;display: none;&#x27; - make it visible to the user)
        // e.g.
        //  Suppose we(you) in the callback function name the element &#x27;elem&#x27;:
        //  $(&#x27;#someElementId&#x27;).append(elem); //append it
        //  $(elem).show();                   //make it visible
        // Execute the callback function:
        clone[&#x27;append&#x27;](element);
      }
      if($settings[&#x27;viewId&#x27;] === undefined) {
        $.extend($settings, {viewId : viewId});
      }
      if($settings[&#x27;isMirror&#x27;] === undefined) {
        $.extend($settings, {isMirror : true});
      }
      if($settings[&#x27;eventUsed&#x27;] === undefined) {
        $.extend($settings, {eventUsed : &#x27;&#x27;});
      }
      if($settings[&#x27;preventDefault&#x27;] === undefined) {
        $.extend($settings, {preventDefault : true});
      }
      // Attach events to the save, update, delete (more?) buttons/submit.
      // For IE we need to specify each element with the viewId individually!
      // $(viewId + &#x27; button,&#x27; + viewId + &#x27; a,&#x27; + viewId + &#x27; submit,&#x27; + viewId + &#x27; i&#x27;)
      $(viewId).find(&#x27;*&#x27;)
        .each(function(i, e) {
          if($(this).hasClass(&#x27;isEvent&#x27;)) {
            $(this)
            //.attr(&#x27;id&#x27;, e.id+&#x27;_&#x27;+viewId)//NoHash)
            .click(function(e) {
              // $object.Start($id, par);
              // $object.Save();
              // console.log(&quot;target name (jQuery): &quot; + $(e.target).attr(&#x27;name&#x27;));
              // console.log(&quot;target name (JS): &quot; + e.target.name);
              // e.target.name is not working on custom elements, such as
              // &lt;foobar href=&quot;#&quot; name=&quot;clearAll&quot; class=&quot;isEvent&quot;&gt;
              //  Click me
              // &lt;/foobar&gt;
              var targetName = $(e.target).attr(&#x27;name&#x27;); // e.target.name
              $object.Start(targetName, e);
              if($settings[&#x27;settings&#x27;][&#x27;preventDefault&#x27;]) {
                e.preventDefault();
              }
            });
          }
          //console.log(i + &quot; &quot; + e.id);
        });

      // Start: Methods

      /**
       * Call the .Save() method whenever you want to save the object.
       * Notice: This is intended behaviour, but the implementation of the
       * method is up to the individual how and what is done when this method
       * is called/executed.
       *
       * @method Save
       * @param {Object} par Provide extra parameters if needed.
       * @return {Object} The object (itself)
       */
      $object.Save = function(par) {
        return $object.Start(&#x27;Save&#x27;, par);
      };

      /**
       * Call the .Update() method whenever you want to update the object.
       * Notice: This is intended behaviour, but the implementation of the
       * method is up to the individual how and what is done when this method
       * is called/executed.
       *
       * @method Update
       * @param {Object} par Provide extra parameters if needed.
       * @return {Object} The object (itself)
       */
      $object.Update = function(par) {
        return $object.Start(&#x27;Update&#x27;, par);
      };

      /**
       * Call the .Delete() method whenever you want to delete the object.
       * Notice: This is intended behaviour, but the implementation of the
       * method is up to the individual how and what is done when this method
       * is called/executed.
       *
       * @method Delete
       * @param {Object} par Provide extra parameters if needed.
       * @return {Object} The object (itself)
       */
      $object.Delete = function(par) {
        return $object.Start(&#x27;Delete&#x27;, par);
      };

      /**
       * Clear
       *
       * Clears a property&#x27;s value in the Model and optionally in the View if &#x27;isMirror&#x27; = true.
       *
       *
       * @method Clear
       * @return {Object} The object (itself)
       */
      $object.Clear = function(prop) {
        $object.Set(prop, &#x27;&#x27;);
        $object[prop] = &#x27;&#x27;;
        return $object;
      };

      /**
       * Clear All
       *
       * Clears all the data in the Model and the View.
       *
       * @method ClearAll
       * @return {Object} The object (itself)
       */
      $object.ClearAll = function() {
        $.each($object.GetModelData(), function(prop) {
          $object.Clear(prop);
        });
        return $object;
      };

      /**
       * AddGetSet
       *
       * Add getter and setter methods for a property
       *
       * Getters and Setters in JavaScript/JScript (ECMAScript) are not an option
       * as it is hard to make it work cross-browser/platform!
       * There is a solution here, but only down to IE9:
       * Source: http://javascriptweblog.wordpress.com/2010/11/15/extending-objects-with-javascript-getters/
       *
       * If changes in the model properties should be reflected in the view
       * then setter and getter methods will be attached using jQuery.
       *
       * Note: Will only be used(exec.) if &#x27;isMirror&#x27; is TRUE.
       *
       * Works in IE 7+: http://jsfiddle.net/cTJZN/
       *
       * @method AddGetSet
       * @param {String} prop The object&#x27;s property name
       * @param {Function} onUpdate callBack function will execute, whenever
       * the get/set event handlers bound with .bind() method are triggered.
       * @return {Object} The object (itself)
       */
      $object.AddGetSet = function(prop) {//, onUpdate) {
        $($object)
          .bind(&#x27;get&#x27;+prop, function(event, ret) {
            ret[&#x27;value&#x27;] = $object[prop];
          })
          .bind(&#x27;set&#x27;+prop, function (event, newVal) {
            //Replace the old value with the new value in the model
            var oldVal = $object[prop];
            //Only update values if they&#x27;re changed
            if(oldVal !== newVal) {
              $object[prop] = newVal;
              //Update the view accordingly
              $object.SetViewFromModel();
              //Make sure that the input will have the change event triggered,
              //so that the views bound to this element will also be updated.
              //This is important in case the model is changed using setTimeout()
              //which will update the model, then this change must simulate
              //a user setting the value of the input.
              $object.TriggerEvent(prop, &#x27;change&#x27;);//.TriggerEvent(prop, &#x27;keyup&#x27;);
              //alert(&quot;OK&quot;);
              //onUpdate(prop, oldVal, newVal);
            }
          });
          return $object;
      };

      /**
       * RemoveGetSet
       *
       * Remove getter and setter methods for a property
       *
       * @method RemoveGetSet
       * @param {String} prop The object&#x27;s property name
       * @return {Object} The object (itself)
       */
      $object.RemoveGetSet = function(prop) {
        $($object)
          .unbind(&#x27;get&#x27;+prop)
          .unbind(&#x27;set&#x27;+prop);

        return $object;
      };

      /**
       * Trigger Event
       *
       * Trigger an event on an input element inside the view
       *
       * @method TriggerEvent
       * @param {String} prop Property name
       * @param {String} evt Event type/name (e.g. &#x27;keyup&#x27;)
       * @return {Object} The object (itself)
       */
      $object.TriggerEvent = function(prop, evt) {
        $(viewId + &#x27; :input[name=&quot;&#x27;+prop+&#x27;&quot;]&#x27;)
          .not(&#x27;.excludeFromModel&#x27;)
          .trigger(evt);

        return $object;
      };

      /**
       * AddProperty
       *
       * Add a property to the Model
       *
       * @method AddProperty
       * @param {String} prop The property name
       * @return {Object} The object (itself)
       */
      $object.AddProperty = function(prop, value) {
        //Add the propery to the Model
        $object[prop] = value;
        // console.log(&quot;Add Property....&quot;);
        // console.log($object);
        $object
          //.AddEvents()
          .AddGetSet(prop);
          //.TriggerEvent(prop, &#x27;keyup&#x27;);
        // console.log(&quot;Added property &quot; + prop + &quot; to the Model.&quot;);
        return $object;
      };

      /**
       * RemoveProperty
       *
       * Remove a property from the Model
       *
       * @method RemoveProperty
       * @param {String} prop The property name
       * @return {Object} The object (itself)
       */
      $object.RemoveProperty = function(prop) {
        $object.RemoveGetSet(prop);
        delete $object[prop];
        //$object.Find(&#x27;[name=&quot;&#x27;+prop+&#x27;&quot;]&#x27;)
        //$(viewId + &#x27; :input[name=&quot;&#x27;+prop+&#x27;&quot;]&#x27;)
          //.not(&#x27;.excludeFromModel&#x27;)
          //.remove();
        // console.log(&quot;Removed property &quot; + prop + &quot; from the Model.&quot;);
        return $object;
      };

      /**
       * Remove
       *
       * NOTE: Must only be used if &#x27;isMirror&#x27; is TRUE.
       *
       * Removes an item from a list object in the model and updates the View.
       *
       * @method Add
       * @param {String} listName The object&#x27;s property name
       * @param {String} item The new value to add to the property list
       * @return {Object} The object (itself)
       */
      $object.Remove = function(listName, prop) {
          var room = $object.Get(prop);
          var rooms = $object.Get(listName);
          rooms.Remove(room);
          $object.FillSelect(listName);
      };

      /**
       * Add
       *
       * NOTE: Must only be used if &#x27;isMirror&#x27; is TRUE.
       *
       * Adds an item to a list object in the model and updates the View.
       *
       * @method Add
       * @param {String} listName The object&#x27;s property name
       * @param {String} item The new value to add to the property list
       * @return {Object} The object (itself)
       */
      $object.Add = function(listName, item) {
          var list = $object.Get(listName);
          list.Add(item);
          $object.FillSelect(listName);
      };

      /**
       * Set
       *
       * NOTE: Must only be used if &#x27;isMirror&#x27; is TRUE.
       *
       * When you need to update a value in the Model and reflect in the View.
       *
       * @method Set
       * @param {String} prop The object&#x27;s property name
       * @param {String} value The new value to set for the property
       * @return {Object} The object (itself)
       */
      $object.Set = function(prop, value){
        if(typeof value === &#x27;function&#x27;) {
          computedProperties.push({ &#x27;name&#x27;: prop, &#x27;func&#x27;: value });
          value = value($object);
        }
        // Add property to model if it&#x27;s not there already.
        // Scenario: User has Model &amp; View without this property, but uses .Set()
        // to set a value in the Model &amp; View, then it should be added!
        // NOTE: isMirror should be TRUE !!! IMPORTANT !!! - by design.
        if($object[&#x27;settings&#x27;][&#x27;isMirror&#x27;] &amp;&amp; !$object.Has(prop)) {
          $object.AddProperty(prop, value);
        }
        // var value2 = [value];
        // if(typeof $object.Get(prop) === &#x27;object&#x27;) {
        //   value2 = [value2];
        // }
        // console.log(prop + &quot; - &quot; + [value]);
        $($object).triggerHandler(&#x27;set&#x27;+prop, [value]);
        //Update databound DOM values
        //Update databound elements with datasrc if specified, otherwise with viewId.
        $object._SetDataboundDomVal(datasrc ? datasrc : viewId, prop, value);
        return $object;
      };

      /**
       * Get
       *
       * NOTE: Must only be used if &#x27;isMirror&#x27; is TRUE.
       *
       * @method Get
       * @param {String} prop The object&#x27;s property name.
       * @return {Object} value The value from the object&#x27;s property.
       */
      $object.Get = function(prop) {
        //http://stackoverflow.com/questions/9145347/jquery-returning-value-from-trigger
        var result = { value : undefined };
        $($object).triggerHandler(&#x27;get&#x27;+prop, [result]);
        return result[&#x27;value&#x27;];
      };

      /**
       * Has
       *
       * Checks if the Model has a given property (true) or not (false).
       *
       * @method Has
       * @param {String} prop The object&#x27;s property name
       * @return {Boolean} TRUE if the property exists. Otherwise FALSE.
       */
      $object.Has = function(prop) {
        if($object.Get(prop) !== undefined) {
          return true;
        }
        return false;
      };

      /**
       * GetDatasrcId
       *
       * Return the (view) ID of the datasource.
       *
       * @method GetDatasrcId
       * @return {Number} The (View) ID of the datasource.
       */
      $object.GetDatasrcId = function() {
        return $object.datasrc;
      };

      /**
       * GetModelData
       *
       * Return&#x27;s a copy of the Model&#x27;s data without it&#x27;s functions.
       * Useful when storing the data.
       *
       * Note: As this object has all of it&#x27;s functions/methods removed, then
       * it&#x27;s not possible to use the .toArray() (if needed for any reason) anymore.
       * Instead use $.makeArray(theObject); which is what .toArray() uses.
       *
       * @method GetModelData
       * @param {Boolean} withSettings If TRUE, then append the settings object.
       * @return {Object} A copy of the Model&#x27;s data (as JSON object literal).
       */
      $object.GetModelData = function(withSettings) {
        var modelObjectData = {};
        $.each($object, function(k, v) {
          // Only add types which aren&#x27;t functions
          if((typeof v).toString() !== &#x27;function&#x27;) {
            //Don&#x27;t add the jQuery object which is used for .Set() &amp; .Get()
            //Regex test on Rubular: http://www.rubular.com/r/KZQH0gdHyy
            if((/jQuery\d*/).test(k)) {
              return true;
            }
            //Only add the settings object if withSettings is TRUE.
            else if(!withSettings &amp;&amp; k === &#x27;settings&#x27;) {
              return true;
            }
            //Add strings and objects (JSON literals and Arrays)
            else {
              modelObjectData[k] = v;
            }
            //console.log(k + &quot; is a &quot; + typeof v);
          }
        });
        return modelObjectData;
      };

      /**
       * GetViewHtml
       *
       * Returns the jQuery object.
       * @method GetViewHtml
       * @return {Object} jQuery object.
       */
      $object.GetViewHtml = function() {
        return $this;
      };

      /**
       * GetViewData
       *
       * Return the View data as an JSON object literal.
       *
       * @method GetViewData
       * @return {Object} The View data as JSON object
       */
      $object.GetViewData = function() {
        //console.log(&quot;GetViewData()&quot;);
        //Get the values from the View (DOM)
        return $(viewId).getSetHtml();
      };

      /**
       * SetViewData
       *
       * Set the View data from the Model (does not update databound elments)
       *
       * @method SetViewData
       * @return {Object} The object (itself)
       */
      $object.SetViewData = function() {
        //Set the values in the DOM
        $(viewId).getSetHtml($object);
      };

      /**
       * SetViewFromModel
       *
       * Updates the elements in the View from the Model (including databound elements).
       *
       * @method SetViewFromModel
       */
      $object.SetViewFromModel = function() {
        //console.log(&quot;SetViewFromModel()&quot;);
        $object.SetViewData();
        var data = $object.GetModelData();
        // console.log(JSON.stringify(data));
        //Update the databound values!!!
        $.each(data, function(key, newVal) {
          $object._SetDataboundDomVal(viewId, key, newVal);
        });
        return $object;
      };

      /**
       * SetModelFromView
       *
       * Update the model and databound elements.
       *
       * This method is internally every time a &#x27;change&#x27; and &#x27;keyup&#x27; event occur
       * in form elements. This is part of the concept to always update the Model,
       * so it is synchronized with the View.
       *
       * It is possible to override the call to this method for the &#x27;keyup&#x27; event
       * if it is implemented manually in the settings. Therefore it&#x27;s important
       * to know that if overriding this event, but still want &#x27;live&#x27; updating
       * of the Model to occur, then this method must be called from the custom
       * implementation of the &#x27;keyup&#x27; event!
       *
       * @method SetModelFromView
       * @param {Boolean} updateDataboundValues TRUE | FALSE - If undefined or
       * true, databound elements inside and/or outside the the View will also
       * get updated. If false, then they won&#x27;t.
       * @return {Object} The object (itself)
       */
       $object.SetModelFromView = function() {
        // Get the values from the View
        var data = $object.GetViewData();
        // console.log(JSON.stringify(data));
        // Update the model using the View values
        $.each(data, function(key, newVal) {
          var oldVal = $object[key];
          // console.log(&quot;SetModelFromView() - key: &quot; + key + &quot;, new value: &quot; + newVal + &quot;, old value: &quot; + oldVal);
          // Only update values if they&#x27;re changed
          // Check the value of oldVal (not newVal)
          // newVal should not be null or undefined!
          if(oldVal !== newVal &amp;&amp; (newVal !== undefined &amp;&amp; newVal !== null)) { // &amp;&amp; typeof oldVal === typeof newVal) {
            // console.log(&quot;Key: &quot; + key + &quot;\nOld value: &quot; + oldVal + &quot; (&quot; + typeof oldVal + &quot;)\nNew value: &quot; + newVal + &quot; (&quot; + typeof newVal + &quot;)&quot;);
            // Update the model with the value from DOM
            $object[key] = newVal;
          }
          // Update databound DOM values even when setting the values on .init()
          // the databound items should ofcourse get updated even if the model
          // data is same as in the view.
          $object._SetDataboundDomVal(viewId, key, newVal);
        });
        // Update computed properties
        $.each(computedProperties, function(k,v) {
          $object.Set(v[&#x27;name&#x27;], v[&#x27;func&#x27;]($object));
        });
        return $object;
      };

      /**
       * Update the databound elements inside or outside the View.
       *
       * @method _SetDataboundDomVal
       * @private
       * @param {String} datasrc A viewId.
       * @param {String} name An element&#x27;s name.
       * @param {String} value A new value.
       *
       * @return {Object} The object (itself)
       */
      $object._SetDataboundDomVal = function(datasrc, name, value) {
        if(value) {
          //console.log(counter + &quot; - datasrc: &quot; + datasrc + &quot; - name: &quot; + name + &quot; - value: &quot; + value);
          var browserVersion = navigator.appVersion;
          // IE 7 &amp; 8
          if(browserVersion.indexOf(&quot;MSIE 7.&quot;) !== -1 || browserVersion.indexOf(&quot;MSIE 8.&quot;) !== -1) {
            // case: &lt;span datasrc=&quot;#viewId&quot; name=&quot;somename&quot;&gt;&lt;/span&gt;
            $(&#x27;div[datasrc=&quot;&#x27;+datasrc+&#x27;&quot;][name=&quot;&#x27;+name+&#x27;&quot;],p[datasrc=&quot;&#x27;+datasrc+&#x27;&quot;][name=&quot;&#x27;+name+&#x27;&quot;],span[datasrc=&quot;&#x27;+datasrc+&#x27;&quot;][name=&quot;&#x27;+name+&#x27;&quot;]&#x27;).text(value);
            // case: &lt;div datasrc=&quot;#viewId&quot;&gt;&lt;span name=&quot;somename&quot;&gt;&lt;/span&gt;&lt;/div&gt;
            $(&#x27;div[datasrc=&quot;&#x27;+datasrc+&#x27;&quot;],p[datasrc=&quot;&#x27;+datasrc+&#x27;&quot;],span[datasrc=&quot;&#x27;+datasrc+&#x27;&quot;]&#x27;).find(&#x27;div[name=&quot;&#x27;+name+&#x27;&quot;],p[name=&quot;&#x27;+name+&#x27;&quot;],span[name=&quot;&#x27;+name+&#x27;&quot;]&#x27;).text(value);
            $(&#x27;div[datasrc=&quot;&#x27;+datasrc+&#x27;&quot;],p[datasrc=&quot;&#x27;+datasrc+&#x27;&quot;],span[datasrc=&quot;&#x27;+datasrc+&#x27;&quot;]&#x27;).find(&#x27;input[name=&quot;&#x27;+name+&#x27;&quot;]&#x27;).val(value);
          }
          else {
            // console.log(&quot;datasrc: &quot; + datasrc + &quot; - name: &quot; + name + &quot; - value: &quot; + value + &quot; - &quot; + $(&#x27;*[datasrc*=&quot;&#x27;+datasrc+&#x27;&quot;]&#x27;).find(&#x27;[name*=&quot;&#x27;+name+&#x27;&quot;]&#x27;).text());
            // case: &lt;span datasrc=&quot;#viewId&quot; name=&quot;somename&quot;&gt;&lt;/span&gt;
            $(&#x27;*[datasrc=&quot;&#x27;+datasrc+&#x27;&quot;][name=&quot;&#x27;+name+&#x27;&quot;]&#x27;).text(value);
            // case: &lt;div datasrc=&quot;#viewId&quot;&gt;&lt;span name=&quot;somename&quot;&gt;&lt;/span&gt;&lt;/div&gt;
            $(&#x27;*[datasrc=&quot;&#x27;+datasrc+&#x27;&quot;]&#x27;).find(&#x27;*[name=&quot;&#x27;+name+&#x27;&quot;]&#x27;).text(value);
            $(&#x27;*[datasrc=&quot;&#x27;+datasrc+&#x27;&quot;]&#x27;).find(&#x27;*[name=&quot;&#x27;+name+&#x27;&quot;]&#x27;).val(value);
          }
          $(&#x27;input[datasrc=&quot;&#x27;+datasrc+&#x27;&quot;][name=&quot;&#x27;+name+&#x27;&quot;]&#x27;).val(value);

          var select = $(&#x27;select[datasrc=&quot;&#x27;+datasrc+&#x27;&quot;][name=&quot;&#x27;+name+&#x27;&quot;]&#x27;);
          $object._FillSelect(select, name, value);
          select = $(&#x27;*[datasrc=&quot;&#x27;+datasrc+&#x27;&quot;]&#x27;).find(&#x27;select[name=&quot;&#x27;+name+&#x27;&quot;]&#x27;);
          $object._FillSelect(select, name, value);
        }
        return $object;
      };

      $object._FillSelect = function(select, name, value) {
        var propValue = $object.Get(name);
        if(typeof propValue === &#x27;object&#x27; &amp;&amp; select.size() &gt; 0) {
          select.empty();
          $.each(value, function(k, v) {
            // var txt = textIsFunction ? v[name.substring(0, name.length-2)]() : v[name];
            // var val = valueIsFunction ? v[value.substring(0, value.length-2)]() : v[value];
            select.append($(&#x27;&lt;option /&gt;&#x27;).attr({&#x27;value&#x27;: v}).text(v));
          });
        }
      };

      /**
       * FillSelect
       *
       * Fill select element with one or more option elements.
       *
       * @method FillSelect
       * @param {Array} prop The property name which holds an array of values
       * @param {String} text The text to be displayed in the option element
       * @param {String} value The value of the option element
       * @return {Object} The object (itself)
       */
      $object.FillSelect = function(prop, text, value) {
        var textIsFunction = !text ? false : text.substring(text.length-2, text.length) === &quot;()&quot;;
        var valueIsFunction = !value ? false : value.substring(value.length-2, value.length) === &quot;()&quot;;
        var items = $object.Get(prop);
        $.each($object.Find(&#x27;select[name*=&quot;&#x27;+prop+&#x27;&quot;]&#x27;), function(k2,select) {
          select = $(select);
          select.empty();
          $.each(items, function(k, v) {
            var txt = !text ? v : textIsFunction ? v[text.substring(0, text.length-2)]() : v[text];
            var val = !value ? v : valueIsFunction ? v[value.substring(0, value.length-2)]() : v[value];
            select.append($(&#x27;&lt;option /&gt;&#x27;).attr({&#x27;value&#x27;: val}).text(txt));
          });
        });
        return $object;
      };

      /**
       * RunEvent
       *
       * Trigger an event if specified in the settings.
       *
       * @method RunEvent
       * @param {String} event The eventName to trigger/execute.
       * @return {Object} The object (itself)
       */
      $object.RunEvent = function(event) {
        var targetName = event.target.name;
        var targetValue = event.target.value;
        //alert(targetName);
        var type = event.type;
        if(type === undefined) {
          type = event;
        }
        if(event === undefined) {
          //console.log(&#x27;event &quot;e&quot; is undefined!&#x27;);
          return;
        }
        if($.trim(targetName).length &gt; 0) {
          if($settings[&#x27;settings&#x27;][type] !== undefined &amp;&amp; $settings[&#x27;settings&#x27;][type] !== null) {
            // alert($settings[&#x27;settings&#x27;][type]);
            $settings[&#x27;settings&#x27;][&#x27;eventUsed&#x27;] = type;
            var modelData = $object[targetName];
            var selectedModelData = modelData;
            // select element (list)
            if(event.target.type.indexOf(&#x27;select&#x27;) !== -1) {
              var selectedIndex = event.target.selectedIndex;
              var selectedOption = event.target.options[selectedIndex];
              if(selectedOption) {
                targetValue = selectedOption.value;
                selectedModelData = modelData[selectedIndex];
              }
            }
            $settings[&#x27;settings&#x27;][type](event, targetName, targetValue, $object, modelData, selectedModelData);
          }
        }
        // else {
        //   console.log(&quot;source element has no name attribute assigned (required!)&quot;);
        // }
        return $object;
      };

      /**
       * Start
       *
       * Execute a method in the controller.
       *
       * @method Start
       * @param {String} method The methods name specified in the controller.
       * @param {Object} par If needed you can provide optional parameters.
       * @return {Object} The object (itself)
       */
      $object.Start = function(method, par) {
        var exec;
        if($object[&#x27;settings&#x27;][&#x27;controller&#x27;] !== undefined) {
          exec = $object[&#x27;settings&#x27;][&#x27;controller&#x27;][method];
        }
        if(exec === undefined) {
          exec = $object[method];
        }
        // console.log(exec);
        // console.log($object[method]);
        // console.log(par);
        if(exec !== undefined &amp;&amp; exec !== null) {
          exec(par, $object);
        } else {
          console.log(&#x27;Missing &#x27; + method + &#x27;() method!&#x27;);
        }
        return $object;
      };

      /**
       * toArray
       *
       * Convert the object to a real Array.
       *
       * @method toArray
       * @return {Array} The object converted into a real Array.
       */
      $object.toArray = function() {
        return $.makeArray($object);
      };

      /**
       * GetViewId
       *
       * Get the ID of the View
       *
       * @method GetViewId
       * @return {String} The View ID
       */
      $object.GetViewId = function() {
        return $object[&#x27;settings&#x27;][&#x27;viewId&#x27;];
      };

      /**
       * Find
       *
       * Find and return one or many element/s within the View using a (id or class) selector.
       *
       * If the elemenet is not found an empty array is returned.
       *
       * @method Find
       * @return {Array} An element from the View.
       */
      $object.Find = function(selector) {
        return $($object.GetViewId() + &#x27; &#x27; + selector);
      };

      /**
       * AddEvents
       *
       * Add events to the object&#x27;s input fields
       *
       * @method AddEvents
       * @return {Object} The object
       */
      $object.AddEvents = function() {
        // Update the model view, whenever a change occurs
        $(viewId + &#x27; :input&#x27;)
          // .not(&#x27;.excludeFromModel&#x27;)
          .focus(function(e){
            // http://jsfiddle.net/PKVVP
            $object.RunEvent(e);
          })
          .blur(function(e) {
            $object.RunEvent(e);
          })
          .change(function(e){
            // Update the model and also the databound elements
            $object.SetModelFromView();
            $object.RunEvent(e);
          })
          .select(function(e) {
            $object.RunEvent(e);
          })
          .submit(function(e) {
            $object.RunEvent(e);
          })
          .click(function(e) {
            // Update the model and also the databound elements
            $object.SetModelFromView();
            $object.RunEvent(e);
          })
          /**
           * keyup event
           *
           * It&#x27;s important to know that when overriding this event,
           * but still want &#x27;live&#x27; updating of the Model to occur,
           * then this method must be called from the custom implementation
           * of the &#x27;keyup&#x27; event!
           *
           * @event keyup ...
           *
           */
          .keyup(function(e){
            // If the &#x27;keyup&#x27; event hasn&#x27;t been specified in the settings, then
            // by default update the Model and databound values using the
            // SetModelFromView() method
            if($settings[&#x27;settings&#x27;][&#x27;keyup&#x27;] === undefined) {
              // Update the model and also the databound elements
              $object.SetModelFromView();
            }
            // e should euqal &#x27;change&#x27;
            $object.RunEvent(e);
          })
          .keypress(function(e) {
            $object.RunEvent(e);
          })
          .keydown(function(e) {
            $object.RunEvent(e);
          });
          return $object;
      };
      // END: methods

      // START: Setup

      // Set the DOM values from the Model
      $object.SetViewFromModel();
      // Initialize the View with the Model data if they aren&#x27;t specified in the Model
      $object.SetModelFromView();
      // If Model property changes should be reflected/displayed in the View:
      // Loop throught the properties within the object and attach events using the
      // jQuery .bind() method. Whenever the user wants to update a value it can
      // be achieved using the .trigger() method, which is implemented in the
      // MVC.Set() and MVC.Get() methods.
      // Note: Changing the Model&#x27;s properties directly won&#x27;t update the view.
      if($settings[&#x27;isMirror&#x27;]) {
        // Loop throught the object&#x27;s properties
        $.each($object.GetModelData(), function(k,v) {
          // console.log(k + &quot; : &quot; + v);
          // var pars = MVC.GetViewData(viewId);
          // Add the Getter and Setter methods
          // n: name, ov: old value, nv: new value
          $object.AddGetSet(k);
          /*, function(n, ov, nv) {
            //alert(n + &quot;: &quot; + ov + &quot;=&gt;&quot; + nv);
            //Update the view accordingly
            //MVC.SetViewFromModel(viewId, $object); //$(viewId).getSetHtml($object);
            $object.SetViewFromModel();

            //Make sure that the input will have the change event triggered,
            //so that the views bound to this element will also be updated.
            //This is important in case the model is changed using setTimeout()
            //which will update the model, then this change must simulate
            //a user setting the value of the input.
            $(&#x27;:input[name=&#x27;+n+&#x27;]&#x27;).not(&#x27;.excludeFromModel&#x27;).trigger(&#x27;change&#x27;);
          });*/
        });
      }
      if($settings[&#x27;autoSaveInterval&#x27;] &gt; 0) {
        $settings[&#x27;eventUsed&#x27;] = &#x27;&quot;autoSave&quot;&#x27;;
        setInterval(function() {
          $object.Save();
        }, $settings[&#x27;autoSaveInterval&#x27;]);
      }
      $object.AddEvents();
      // Add the settings to the Model object
      $settings = { settings : $settings };
      $.extend($object, $settings);
      // alert(JSON.stringify($object, null, 2));
      /**
       * To keep the code which belongs to the object, but normally would be
       * placed after object instantiation, we instead want to place it inside
       * the .init() method, which gets executed right after the object has been
       * created.
       */
      var init = $object[&#x27;init&#x27;];
      //Do not run the .init() method if it is undefined or null
      if(init !== undefined &amp;&amp; init !== null) {
        init($object);
      }
      return $object;
    }
  });
})(jQuery);
/**
 * Get or set HTML (DOM) values
 *
 * Inspired by formParams: http://jquerypp.com/#formparams
 *
 * @param {Object} jQuery
 * @class getSetHtml
 */
(function( $ ) {
  $.fn.extend({
    /**
     * getSetHtml
     *
     *
     * Get or set HTML (DOM) values.
     * If you pass this method any parameters it will try to set the HTML.
     * Otherwise it will try get the HTML values from the view.
     *
     *
     * @param  {Object} params Object literal with keys that correspond with
     * either an ID or NAME attribute of an element in the View (DOM).
     * @return {Object} Object literal with data from the View (DOM).
     *
     * @method getSetHtml
     */
    getSetHtml: function( params ) {
      if(params !== undefined) {
        return this.setValues(params);
      }
      else {
        return this.getValues();
      }
    },
    getInputElements : function(target) {
      return target.find(&#x27;input,select,textarea&#x27;).not(&#x27;.excludeFromModel&#x27;);
    },
    getElementKey : function(element) {
      var key = $(element).attr(&quot;datafld&quot;);
      if(key === undefined) {
        key = $(element).attr(&quot;id&quot;);
      }
      if(key === undefined) {
        key = $(element).attr(&quot;data-bind&quot;);
      }
      return key;
      //return $(element).attr(&quot;datafld&quot;) ? undefined : $(element).attr(&quot;id&quot;);
    },
    getBindableElements : function(target) {
      //return target.find(&#x27;p,span,div&#x27;).filter(&#x27;:not(.excludeFromModel)&#x27;);
      return target.find(&#x27;*[data-bind], *[datafld]&#x27;).filter(&#x27;:not(.excludeFromModel)&#x27;);
    },
    setValues : function(params) {
      //console.log(&#x27;setValues called!&#x27;);
      //console.log(this.getBindableElements(this));
      //Set the values for  &#x27;p&#x27;, &#x27;div&#x27; and &#x27;span&#x27; elements
      var $this = this;
      $this.getBindableElements(this).each(function() {
        var key = $this.getElementKey(this);
        if(key === undefined) {
          return;
        }
        //alert(key);
        var value = params[key];
        // console.log(key + &quot; = &quot; + value);
        //console.log(value);
        $(this).html(value);
        //var toReplace = $.trim($(this).text());
        //alert(toReplace);
      });

      $this.getInputElements(this).each(function(){
        var value = params[ $(this).attr(&quot;name&quot;) ], $this;
        // console.log(value);
        // Don&#x27;t do all this work if there&#x27;s no value
        if ( value !== undefined) {
          $this = $(this);
          // Select element
          if ( $this.is(&quot;select&quot;) ) {
            // Fill select with option elements if select value is null
            if(!$this.val()) {
              var selectElement = $this;
              selectElement.empty();
              $.each(value, function(k,v) {
                var txt = v;
                var val = v;
                if(typeof v === &#x27;object&#x27;) {
                  $.each(v, function(k2,v2) {
                    var k2isFunc = typeof k2 === &#x27;function&#x27;;
                    var v2isFunc = typeof v2 === &#x27;function&#x27;;
                    // console.log(v2isFunc);
                    txt = v2isFunc ? v.toString() : k2;
                    val = v2isFunc ? v.toString() : v2;
                  });
                }
                // console.log(&quot;text: &quot; + txt + &quot; - value: &quot; + val);
                selectElement.append($(&#x27;&lt;option /&gt;&#x27;).attr({&#x27;value&#x27;: val}).text(txt));
              });
            }
            else {
              // alert($this.attr(&#x27;name&#x27;) + &quot; has values!&quot;);
            }
          }
          // Radio element
          else if ( $this.is(&quot;:radio&quot;) ) {
            if ( $this.val() === value ) {
              $this.attr(&quot;checked&quot;, true);
            }
          }
          // Checkbox element
          else if ( $this.is(&quot;:checkbox&quot;) ) {
            // Convert single value to an array to reduce
            // complexity
            if(value) {
              $this.attr(&quot;checked&quot;, true);
            }
            else {
              value = $.isArray( value ) ? value : [value];
              if ( $.inArray( $this.val(), value ) &gt; -1) {
                $this.attr(&quot;checked&quot;, true);
              }
            }
            $this.val( value );
          }
          // Other elements
          else {
            $this.val( value );
          }
        }
      });

    },
    getValues : function() {
      var data = {},
          formData = {};
      var $this = this;
      $this.getInputElements(this).each(function() {
        var elm = $(this);
        var type = elm.attr(&#x27;type&#x27;),
            name = elm.attr(&#x27;name&#x27;),
            value = elm.val();
        if(type === &#x27;submit&#x27; || !name) {
          return;
        }

        //console.log(&quot;type: &quot; + type + &quot; - name: &quot; + name + &quot; - value: &quot; + value);
        if(elm.hasClass(&#x27;isNumber&#x27;)) {
          value = parseInt(value, null);
        }

        // Select element
        if(elm.is(&#x27;select&#x27;)) {
          var selectValues = MVC.List([]);
          $.each(elm.find(&#x27;option&#x27;), function(k,v) {
            // selectValues.push($(v).val());
            selectValues.Add($(v).val());
          });
          value = selectValues;
          formData[name] = value;
        }
        // Checkbox element
        else if(elm.is(&#x27;:checkbox&#x27;)) {
          value = false;
          if(elm.attr(&#x27;checked&#x27;) | elm.prop(&#x27;checked&#x27;)) {
            value = true;
          }
          formData[name] = value;
        }
        // Radio element
        else if(elm.is(&#x27;:radio&#x27;)) {
          if(elm.attr(&#x27;checked&#x27;) | elm.prop(&#x27;checked&#x27;)) {
            formData[name] = value;
          }
        }
        // Other elements
        else {
          formData[name] = value;
        }
      });

      $this.getBindableElements(this).each(function() {
        var elem = $(this);
        var value = elem.text();
        if(value !== undefined) {
          var key = $this.getElementKey(this);
          if(key === undefined) {
            return;
          }
          if(elem.hasClass(&#x27;isNumber&#x27;)) {
            value = parseInt(value, null);
          }
          //alert(key + &quot; = &quot; + value);
          data[key] = value;
        }
      });
      $.extend(data, formData);
      //alert(CMN.JSON.stringify(data, null, 2));
      return data;
    }
  });
})(jQuery);

// http://stackoverflow.com/questions/1038746/equivalent-of-string-format-in-jquery/2648463#2648463
String.prototype.format = String.prototype.f = function() {
  var s = this,
      i = arguments.length;
  while (i--) {
      s = s.replace(new RegExp(&#x27;\\{&#x27; + i + &#x27;\\}&#x27;, &#x27;gm&#x27;), arguments[i]);
  }
  return s;
};
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
