<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Example 9</title>
    <!--IE fixes -->
    <script type="text/javascript" src="../lib/json2.js"></script>
    <script type="text/javascript"> if (!window['console']) console = {log: function() {}}; </script>
    <!--//end IE fixes -->
    <!--<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.js"></script>-->
    <script type="text/javascript" src="../lib/jquery-1.7.2.min.js"></script>
    <script type="text/javascript" src="../simple.mvc.js"></script>
    <!--optional:-->
    <script type="text/javascript" src="../../simplemvc-showcase/lib/bootstrap/js/bootstrap.min.js"></script>
    <link type="text/css" rel="stylesheet" href="../../simplemvc-showcase/lib/bootstrap/css/bootstrap.css" />
    <!--//end optional-->
  </head>
  <body style="background-color:#fcfcfc; border:1px solid #ccc; padding: 5px;">
    <h1>Setting values</h1>
    <p>
      Demonstrates the difference between using <b>obj.Set(n, v);</b> and <b>obj[n] = v;</b>
    </p>
    <!-- View ID: testArea -->
    <div id="testArea">
      <input name="theValue" type="text" disabled="true" class="span12" /> <button class="btn btn-inverse" name="Clear">Clear</button>
      <br />
      <p>
        <h3>Set the value in both View and the Model using obj.Set(n, v);</h3>
        <p>
          <i>
            Notice that the .Set(n, v) method will update the View with values from the Model when called. This is by design, but can seem 
            a bit confusing (maybe) to start with.
            <br />
            To test if the above statement is true, try click on the buttons in this order:
            <br />
            button #1, then button #2 (notice the input values and click clear), 
            then click button #2, then button #1
          </i>
        </p>
        <br />
        When the name changes in the view or the model, this value should change too. Click on the button to try it out...
        <br />
        Go ahead and <button class="btn btn-inverse" name="setValueInViewAndModel">Try it! (button #1)</button>
        <br />
        <br />
        <h3>Set the value only in the Model using obj[n] = v;</h3>
        <br />
        Even though that worked... this won't...
        <br />
        Go ahead and <button class="btn btn-inverse" name="setValueInModelOnly">Try it! (button #2)</button>
        <br />
        <br />
        <h3>Set the value only in the Model using obj[n] = v; and update the View with values from the Model using the .SetViewFromModel() method.</h3>
        <br />
        That did only set the value in the Model and not in the View. To update the View with the Model's values...
        <br />
        Go ahead and <button class="btn btn-inverse" name="setValueInModelOnlyButUpdateViewFromModel">Try it! (button #3)</button>
      </p>
    </div><!-- //end of view -->
    <script>
    var obj, ctr;
    
    $(function() {
      
      ctr = MVC.Controller({
        Clear : function() {
          clearInputs();
          printDebugObj();
        },
        setValueInViewAndModel : function() {
          obj.Set('theValue', 'Value is both in the Model and View');
          printDebugObj();
        },
        setValueInModelOnly : function() {
          //clearInputs();
          obj['theValue'] = 'Value is only in model';
          printDebugObj();
        },
        setValueInModelOnlyButUpdateViewFromModel : function() {
          //clearInputs();
          obj['theValue'] = 'Value was originally only in the Model, but values in the View have been set from the Model.';
          obj.SetViewFromModel();
          printDebugObj();
        }
      });
      
      obj = MVC.ModelView('#testArea', {
        id: $.now()
      }, {
        controller : ctr
      });
      
      function clearInputs() {
        obj.Clear('theValue');
      }
      
      function printDebugObj() {
        DebugObj('#debug', { o1 : { object : obj, readDom : true } });
      }
      
      //Case 1:
      //Read the values from the DOM and write the object to the console
      //var domObj = obj.GetViewData();
      
      //Case 2:
      //Change the model, but not the view
      //Get the DOM values
      var domObj = obj.GetViewData();
      //Change the 'type' property directly in the model, which will not update the view (in any case!) 
      obj.type = 'Type changed in Model, but not in View!';
      
      //Case 3:
      //Change the value in the model using the .Set() method, which will 
      //cause the view to update IF and only if the parameter 'reflectModelChangeInView' is set to be 'true'
      var oldValue = obj.Get('type');
      var newValue = 'Type changed in Model and in View!';
      //alert(obj['type'] + " - " + obj.Get('type'));
      obj.Set('type', newValue);
      //alert(obj['type']);
      //Reset the type to default value:
      obj.Set('type', oldValue);
    });
    </script>
    <div id="debug"> </div>
    <script src="debug.js"></script>
  </body>
</html>