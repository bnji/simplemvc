<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Example 5</title>
    <!--IE fixes -->
    <script type="text/javascript" src="../lib/json2.js"></script>
    <script type="text/javascript"> if (!window['console']) console = {log: function() {}}; </script>
    <!--//end IE fixes -->
    <!--<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.js"></script>-->
    <script type="text/javascript" src="../lib/jquery-1.7.2.min.js"></script>
    <script type="text/javascript" src="../simple.mvc.js"></script>
    <!--optional:-->
    <script type="text/javascript" src="../../simplemvc-showcase/lib/bootstrap/js/bootstrap.min.js"></script>
    <link type="text/css" rel="stylesheet" href="../../simplemvc-showcase/lib/bootstrap/css/bootstrap.css" />
    <!--//end optional-->
  </head>
  <body style="background-color:#fcfcfc; border:1px solid #ccc; padding: 5px;">
    <h1>Set View / Model Data</h1>
    
    <h2>Inside the View</h2>
    <!-- View ID: testArea -->
    <div id="testArea">
      Name: <input type="text" name="name" id="name" value="" />
      <br />
      Address: <input type="text" name="address" id="address" value="" />
      <br />
      <p>
        Reflect Changes within the Model in the View?
        <br />
        This doesn't have any effect as for the time being... 
      </p>
      <select name="reflectModelChangeInView" id="reflectModelChangeInView">
        <option value="true">yes</option>
        <option value="false">no</option>
      </select>
    </div><!-- //end of view -->
    <button class="btn btn-inverse" id="setModelFromView">Set Model From View</button>
    <button class="btn btn-inverse" id="setViewFromModel">Set View Form Model</button>
    <button class="btn btn-inverse" id="changeModel">Change Model</button>
    <button class="btn btn-inverse" id="changeModelView">Change Model & View</button>
    <script>
    var obj,
        viewId = '#testArea';
    
    $(function() {
      obj = MVC.ModelView(viewId, { 
        name : 'foo',
        address : 'bar'
      }, {
        reflectModelChangeInView : true,
        change : function(e, n, v) {
          /*if(n === 'reflectModelChangeInView') {
            //obj['settings'][n] = v;
            obj.RemoveGetSet('name');
          }*/
          DebugObj('#debug', { o1 : { object : obj, readDom : true } });
        },
        keyup : function(e, n, v) {
          obj.SetModelFromView();
          DebugObj('#debug', { o1 : { object : obj, readDom : true } });
        }
      });
      
      $('#setModelFromView').click(function() {
        alert('The Model is always updated with values from the View.\n\nHowever...\n\nIf the "keyup" and/or "change" event is implemented manually, then remember to make a "call" to the method .SetModelFromView() to update the Model values.');
      });
      
      $('#setViewFromModel').click(function() {
        obj['name'] = 'Name was changed in Model! - Now you see it after updating the View from the Model.';
        obj['address'] = 'Name was changed in Model! - Now you see it after updating the View from the Model.';
        obj.SetViewFromModel();
        DebugObj('#debug', { o1 : { object : obj, readDom : true } });
      });
      
      $('#changeModel').click(function() {
        obj['name'] = 'Name changed in Model, but not in View!';
        DebugObj('#debug', { o1 : { object : obj, readDom : true } });
      });
      
      $('#changeModelView').click(function() {
        var newValue = 'Name changed in Model and in View!';
        //alert(obj['settings']['reflectModelChangeInView']);
        obj.Set('name', newValue);
        DebugObj('#debug', { o1 : { object : obj, readDom : true } });
      });
      
      DebugObj('#debug', { o1 : { object : obj, readDom : true } });
      
      /*
      //Case 1:
      //Read the values from the DOM and write the object to the console
      //var domObj = obj.GetViewData();
      
      //Case 2:
      //Change the model, but not the view
      //Get the DOM values
      var domObj = obj.GetViewData();
      //Change the 'type' property directly in the model, which will not update the view (in any case!) 
      obj['type'] = 'Type changed in Model, but not in View!';
      
      //Case 3:
      //Change the value in the model using the .Set() method, which will 
      //cause the view to update IF and only if the parameter 'reflectModelChangeInView' is set to be 'true'
      var oldValue = obj.Get('type');
      var newValue = 'Type changed in Model and in View!';
      obj.Set('type', newValue);
      //Reset the type to default value:
      obj.Set('type', oldValue);
      */
    });
    </script>
    <div id="debug"> </div>
    <script src="debug.js"></script>
  </body>
</html>