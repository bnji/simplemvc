<!--IE fixes -->
<script type="text/javascript" src="lib/json2.js"></script>
<script type="text/javascript"> if (!window.console) console = {log: function() {}}; </script>
<!--//end IE fixes -->
<!--<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>-->
<script type="text/javascript" src="lib/jquery-1.7.2.min.js"></script>
<script type="text/javascript" src="simple.mvc.js"></script>
<link rel="stylesheet" type="text/css" href="lib/jasmine/jasmine.css" />
<script type="text/javascript" src="lib/jasmine/jasmine.js"></script>
<script type="text/javascript" src="lib/jasmine/jasmine-html.js"></script>

<span id="datafldTestElementDatabound" name="datafldTestElement" datasrc="#testArea">datafldTestElementValue</span>
<span id="idTestElementDatabound" name="idTestElement" datasrc="#testArea">idTestElementValue</span>

<div id="testArea" style="display: none;">
  <span datafld="datafldSpan"> </span>
  <br />
  <input name="datafldTestElement" type="text" />
  <br />
  <input name="idTestElement" type="text" />
  ID (input): <input class="isNumber" name="id" id="id" />
  <br />
  <input name="id2" id="id2" />
  <br />
  ID (span - updating when input ID changes): <span class="excludeFromModel" datasrc="#testArea" name="id" id="idDatabound"> </span>
  <input class="excludeFromModel isNumber" datasrc="#testArea" name="id" />
  <span class="excludeFromModel" id="imNotInTheModel">imNotInTheModelValue</span>
  <input class="excludeFromModel" id="imNotInTheModelInput" value="imNotInTheModelInputValue" />
  <br />
  Type: <input type="text" name="type" />
  <br />
  <input type="text" name="canIjoinTheModelEvenNotSpecified" value="I'm not specified in the model, but the view wants me to join" class="" />
  
  <input type="submit" name="submitButton" value="submitValue" />
  <br />
  <input type="button" name="save" id="save" value="save" />
  <input type="button" name="update" id="update" value="update" />
  <input type="button" name="delete" id="delete" value="delete" />
  
</div>
<div id="testArea2" style="display: none;">
  ID (input): <input class="isNumber" name="id3" id="id3" />
  <br />
  Type: <input type="text" name="type2" value="typeValFromView" />
  <br />
  <span id="attachGetterSetterEvenNotSpecifiedInModel"> </span>
</div>

<div id="testArea3" style="display: none;">
  <h2>Testing classes</h2>
  <span class="isNumber" id="spanIsNumber">123456</span>
  <span id="spanIsNotNumber">123456</span>
  <input class="isNumber" name="inputIsNumber" type="text" value="123456" />
  <input name="inputIsNotNumber" type="text" value="123456" />
</div>

<div id="testAreaEmpty" style="display: none;">
  <input type="text" name="inModel" value="foobar" />
</div>

<div style="display:none;">
  <h1>Outside the View</h1>
  <p>
    This input element will be databound to the property 'type' in the MVC 'testArea'.
    <br /> 
    <span datasrc="#testArea" name="type" id="typeDatabound">&nbsp;</span>
  </p>
</div>
<script>
$(function() {
  //Unit testing setup
  (function() {
    var jasmineEnv = jasmine.getEnv();
    jasmineEnv.updateInterval = 1000;

    var htmlReporter = new jasmine.HtmlReporter();

    jasmineEnv.addReporter(htmlReporter);

    jasmineEnv.specFilter = function(spec) {
      return htmlReporter.specFilter(spec);
    };

    var currentWindowOnload = window.onload;

    window.onload = function() {
      if (currentWindowOnload) {
        currentWindowOnload();
      }
      execJasmine();
    };

    function execJasmine() {
      jasmineEnv.execute();
    }

  })();
});


describe("MVC Object which reflects model changes in the DOM ---- ", function() {
  var timerCallback,
      viewId,
      obj,
      ctr,
      settings,
      onChangeResultData = {};
  beforeEach(function(){
    timerCallback = jasmine.createSpy('timerCallback');
    jasmine.Clock.useMock();
    
    viewId = '#testArea';
    
    ctr = MVC.Controller({
      Save : function(o, par) {
        expect(par).not.toBe(undefined);
        expect(par).toBe('saveExtraParameter');
        expect(obj).toEqual(o);
      },
      Update : function(o, par) {
        expect(par).not.toBe(undefined);
        expect(par).toBe('updateExtraParameter');
        expect(obj).toEqual(o);
      },
      Delete : function(o, par) {
        expect(par).not.toBe(undefined);
        expect(par).toBe('deleteExtraParameter');
        expect(obj).toEqual(o);
      }
    });
    
    settings = {
      controller : ctr,
      reflectModelChangeInView : true,
      change : function(e, n, v) {
        onChangeResultData = {'name':n,'value':v};
        //return {'name':n,'value':v};
      }
    };
    
    obj = MVC.ModelView(viewId, {
      datafldSpan : '',
      datafldTestElement : '',
      idTestElement : '',
      id : 123,
      id2 : 456,
      type : 'typeVal'
    }, settings);
  });
  
  it("Intial value of 'id' to be 123 (Number) and not '123' (String), because it has the class 'isNumber'", function() {
    expect(obj['id']).not.toBe('123');
    expect(obj['id']).toBe(123);
  });
  
  it("Intial value of 'id2' to be '456' (String) and not 456 (Number), because it does not have the class 'isNumber'", function() {
    expect(obj['id2']).not.toBe(456);
    expect(obj['id2']).toBe('456');
  });
  
  it("Initial value of 'type' to be 'typeVal'", function() {
    expect(obj['type']).toBe('typeVal');
  });
  
  it("obj should not be null", function() {
    expect(obj).not.toBe(null);
  });
  
  it("obj should not be undefined", function() {
    expect(obj).not.toBe(undefined);
  });
  
  it("Calling MVC.Save() method should work", function() {
    //MVC.Save(obj, 'saveExtraParameter');
    obj.Save('saveExtraParameter');
  });
  
  it("Calling MVC.Update() method should work", function() {
    //MVC.Update(obj, 'updateExtraParameter');
    obj.Update('updateExtraParameter');
  });
  
  it("Calling MVC.Delete() method should work", function() {
    //MVC.Delete(obj, 'deleteExtraParameter');
    obj.Delete('deleteExtraParameter');
  });
  
  it("using datafld and id should work", function() {
    var newVal = ''+$.now();
    
    obj.Set('datafldSpan', newVal);
    expect(obj.Get('datafldSpan')).toBe(newVal);
    
    obj.Set('datafldTestElement', newVal);
    var domVal = $('#datafldTestElementDatabound').text();// obj.Get('datafldTestElement');
    expect(domVal).toBe(newVal);
    
    obj.Set('idTestElement', newVal);
    domVal = $('#idTestElementDatabound').text();// obj.Get('idTestElement');
    expect(domVal).toBe(newVal);
  });
  
  it("elements which have the class 'excludeFromModel' should not be included in the Model (even when inside the (DOM) View)", function() {
    expect(obj['imNotInTheModel']).toBe(undefined);
    expect(obj['imNotInTheModelInput']).toBe(undefined);
  });
  
  it("changing Model property using the MVC.Set() method should update the DOM value when 'reflectModelChangeInView' : true", function() {
    var newVal = ''+$.now();
    //MVC.Set(obj, 'type', newVal);
    obj.Set('type', newVal);
    var domVal = obj.GetViewData()['type'];// MVC.GetViewData(viewId)['type'];
    //alert(obj['type'] + " - " + MVC.Get(obj, 'type') + " - " + MVC.GetViewData(viewId)['type']);
    expect(domVal).toBe(newVal);
  });
  
  it("changing Model property by reference should not update the DOM value", function() {
    //alert(MVC.GetViewData(viewId)['type']);
    var newVal = ''+$.now();// MVC.Set(obj, 'type', ''+Date.now());
    obj['type'] = newVal;
    var domVal = obj.GetViewData()['type'];//MVC.GetViewData(viewId)['type'];
    //alert(MVC.GetViewData(viewId)['type']);
    expect(domVal).not.toBe(obj['type']);
  });
  
  it("change event should work", function() {
    var newVal = ''+$.now();
    //$('#testArea #id').val(newVal).trigger('change');
    //var ret = obj['settings']['change']('key', 'val');
    //MVC.Set(obj, 'type', newVal);
    obj.Set('type', newVal);
    $('#testArea #type').val(newVal).trigger('change');
    //onChangeResultData = obj obj['settings']['change'](null, 'key', 'val');
    //alert(JSON.stringify(onChangeResultData));
    expect(onChangeResultData['name']).toBe('type');
    expect(onChangeResultData['value']).toBe(newVal);
  });
  
  it("obj settings should contain the viewId", function(){
    expect(obj['settings']['viewId']).toEqual(viewId);
    //obj['settings']['onChange']();
  });
  
  it("Testing if getter method is working", function() {
    //obj.type = "hello";
    var getVal = obj.Get('type');// MVC.Get(obj, 'type');
    expect(obj.type).toBe(getVal);
  });
  
  it("Elements in the view should be threated as property of the model and therefore added to the model even not specified in the model", function() {
    var domVal = obj.GetViewData();//MVC.GetViewData('#testArea', obj);
    expect(domVal['canIjoinTheModelEvenNotSpecified']).not.toBe(null);
    expect(domVal['canIjoinTheModelEvenNotSpecified']).not.toBe(undefined);
    expect(obj['canIjoinTheModelEvenNotSpecified']).not.toBe(null);
    expect(obj['canIjoinTheModelEvenNotSpecified']).not.toBe(undefined);
    expect(domVal['canIjoinTheModelEvenNotSpecified']).toBe(obj.canIjoinTheModelEvenNotSpecified);
  });
    
  it("Changing Model property directly should not update the dom value", function() {
    var newVal = ''+$.now();
    obj.id = newVal;
    expect(obj['id']).toBe(newVal);
    var dom = obj.GetViewData();// MVC.GetViewData('#testArea', obj);
    expect(dom['id']).not.toBe(newVal);
  });
  
  it("Updating an input element should update the model accordingly", function() {
    var newVal = $.now();
    $('#testArea #id').val(newVal).trigger('change');
    expect(obj['id']).toBe(newVal);
    var dom = obj.GetViewData();//MVC.GetViewData('#testArea', obj);
    expect(dom['id']).toBe(newVal);
  });
  
  it("Updating an input element which has another element databound to it should be updated with same information", function() {
    var newVal = $.now();
    $('#id').val(newVal).trigger('change');
    //alert(obj.id);
    expect(obj['id']).toBe(newVal);
    var dom = obj.GetViewData();//MVC.GetViewData('#testArea', obj);
    expect(dom['id']).toBe(newVal);
    //var databoundValue = $('#testArea').getSetHtml();
    var databoundValue = parseInt($('#testArea #idDatabound').text());
    //alert(JSON.stringify(databoundValue, null, 2));
    expect(databoundValue).toBe(newVal);
  });
  
  it("Updating a property in the model using MVC.Set() will also update the DOM value.", function() {
    var newVal = $.now();
    //MVC.Set(obj, 'id', newVal);
    obj.Set('id', newVal);
    expect(obj['id']).toBe(newVal);
    var dom = obj.GetViewData(); //MVC.GetViewData('#testArea', obj);
    expect(dom['id']).toBe(newVal);
  });
  
  it("View object should be equal to model object (JSON)", function() {
    var domObj = obj.GetViewData();//MVC.GetViewData('#testArea', obj);
    settings = { settings : settings };
    $.extend(domObj, settings);
    domObj = JSON.stringify(domObj);
    var modObj = JSON.stringify(obj);
    //alert(MVC.Debug(modObj) + "\n\n" + MVC.Debug(domObj));
    //var a1, a2;
    //a1 = $.makeArray(domObj);
    //a2 = $.makeArray(modObj);
    //alert(a1.sort() + "\n\n" + a2.sort());
    //expect(a1.sort()).toEqual(a2.sort());
    //var a1 = jQuery.makeArray(domObj);// ($.map(domObj, function (a) { return a; })).sort();
    //var a2 = jQuery.makeArray(modObj);// ($.map(modObj, function (a) { return a; })).sort();
    //alert($.isArray(a1) + "\n" + $.isArray(a2));
    //alert(a1.sort() + "\n----\n" + a2.sort());
    //alert(domObj + "\n----\n" + modObj);
    //expect(a1.sort()).toEqual(a2.sort());
    expect(modObj).toEqual(domObj);
  });
  
  it("View object should be equal to model object (JSON) after the model has been updated", function() {
    //MVC.Set(obj, 'id', 'foo');
    obj.Set('id', 'foo');
    //MVC.Set(obj, 'type', 'bar');
    obj.Set('type', 'bar');
    var domObj = obj.GetViewData();//MVC.GetViewData('#testArea', obj);
    settings = { settings : settings };
    $.extend(domObj, settings);
    domObj = JSON.stringify(domObj);
    var modObj = JSON.stringify(obj);
    expect(modObj).toEqual(domObj);
  });
  
  it("Should not work to get the value from a submit button", function() {
    expect(obj['submitButton']).toBe(undefined);
  });
  
  it("Should work updating the value of a property using setTimeout() (simulating input change from user)", function() {
    setTimeout(function() {
      timerCallback();
    }, 3000);
    //MVC.Set(obj, 'type', 'delay change!');
    obj.Set('type', 'delay change!');
    var domVal = $('#typeDatabound').html();
    expect(domVal).toBe(obj.type);
    //alert(domVal + " =?= " + obj.type);
  });
  
  it("Should work converting the object Model to an array using .toArray() method", function() {
    expect($.isArray(obj)).toBe(false);
    expect($.isArray(obj.toArray())).toBe(true);
  });
  
});


describe("MVC Object which does NOT reflect model changes in the DOM", function() {
  var obj,
      viewId;
  
  beforeEach(function(){
    viewId = '#testArea';
    obj = MVC.ModelView(viewId, {
      id : 123,
      type : 'typeVal'
    }, {
      reflectModelChangeInView:false,
      change: function(e, n, v) {
        alert("ok");
      }
    });
  });
  
  it("Changing Model property using the MVC.Set() method should not set the property or the DOM value when 'reflectModelChangeInView' : false", function() {
    var newVal = ''+Date.now();
    //MVC.Set(obj, 'type', newVal);
    obj.Set('type', newVal);
    var domVal = obj.GetViewData()['type'];//MVC.GetViewData(viewId)['type'];
    expect(domVal).not.toBe(newVal);
    var propVal = obj['type'];
    expect(propVal).not.toBe(newVal);
  });
  
  it("Getting a Model property value using the MVC.Get() method should be undefined when 'reflectModelChangeInView' : false", function() {
    var objVal = obj.Get('type'); //MVC.Get(obj, 'type');
    expect(objVal).toBe(undefined);
  });
  
  it("Updating Model properties (and therefor also DOM values) using MVC.Set() should not work", function() {
    var newVal = Date.now();
    //MVC.Set(obj, 'id', newVal);
    obj.Set('id', newVal);
    expect(obj['id']).not.toBe(newVal);
    var dom = obj.GetViewData();//MVC.GetViewData('#testArea', obj);
    expect(dom['id']).not.toBe(newVal);
  });
  
});

describe("MVC Object without settings", function() {
  var obj,
      viewId;
  
  beforeEach(function(){
    viewId = '#testArea';
    obj = MVC.ModelView(viewId, {
      id : 123,
      type : 'typeVal'
    });
  }); 
  
  it("obj settings should never be undefined or null, even when not specified", function(){
    expect(obj['settings']).not.toBe(undefined);
    expect(obj['settings']).not.toBe(null);
  });
  
  it("obj settings should contain the viewId property and to equal viewId", function(){
    expect(obj['settings']['viewId']).toEqual(viewId);
  });
  
  it("obj settings should contain the reflectModelChangeInView property and be set to true", function(){
    expect(obj['settings']['reflectModelChangeInView']).toEqual(true);
  });
  
});

describe("MVC Object with autosave", function() {
  var value, flag;
  var timerCallback,
      obj,
      ctr,
      viewId,
      counter = 0;
      
  ctr = MVC.Controller({
    Save : function(o, currentTimePar) {
      //alert(counter);
      /*timerCallback();
        
      setTimeout(function() {
        expect(counter).toBeGreaterThan(2);
      }, 1000);*/
     
      setTimeout(function() {
        timerCallback();
        counter++;
      }, 100);
  
      expect(timerCallback).not.toHaveBeenCalled();
      alert(counter);
      jasmine.Clock.tick(101);
      alert(counter);
      jasmine.Clock.tick(1001);
      alert(counter);
      expect(timerCallback).toHaveBeenCalled();
    }
  });
  
  beforeEach(function(){
    timerCallback = jasmine.createSpy('timerCallback');
    jasmine.Clock.useMock();
    
    viewId = '#testArea';
    obj = MVC.ModelView(viewId, {
      id : 123,
      type : 'typeVal'
    }, {
      controller : ctr,
      autoSaveInterval : 5000
    });
  });
  
  xit("autoSaveInterval = 5000 should call the Save() method every 5 seconds", function() {
    //MVC.Save(obj, $.now());
    obj.Save($.now());
  });
  
  xit("should support async execution of test preparation and exepectations", function() {
    runs(function() {
      flag = false;
      value = 0;

      setTimeout(function() {
        flag = true;
      }, 500);
    });
    
    waitsFor(function() {
      value++;
      return flag;
    }, "The Value should be incremented", 750);
    
    runs(function() {
      expect(value).toBeGreaterThan(0);
      
    });
  });
  
});

describe("MVC Object Getter & Setter", function() {
  var obj,
      viewId;
  
  beforeEach(function(){
    viewId = '#testArea2';
    obj = MVC.ModelView(viewId, {
      id3 : 123,
      type2 : 'typeValFromModel'
    }, {
      reflectModelChangeInView : true
    });
  });
  
  it("Getter & Setter methods should be attached to properties which are specified by the DOM but not in Model (when 'reflectModelChangeInView' : true)", function() {
    var newVal = ''+$.now();
    //MVC.Set(obj, 'attachGetterSetterEvenNotSpecifiedInModel', newVal);
    obj.Set('attachGetterSetterEvenNotSpecifiedInModel', newVal);
    var domVal = obj.Get('attachGetterSetterEvenNotSpecifiedInModel');// MVC.Get(obj, 'attachGetterSetterEvenNotSpecifiedInModel'); //MVC.GetViewData(viewId)['attachGetterSetterEvenNotSpecifiedInModel'];
    expect(domVal).toBe(newVal);
  });
  
  it("Should work removing getters & setters and add them again to a property in the Model", function() {
    var newVal = '', lastTypeValBeforeRemovedGetterSetter = '';
    expect(obj.Get('type2')).toEqual('typeValFromModel'); //alert('Original value from View: ' + obj.Get('type2'));
    newVal = 'type2 - Changed In Model & View';
    obj.Set('type2', newVal);
    lastTypeValBeforeRemovedGetterSetter = newVal;
    expect(obj.Get('type2')).toEqual(newVal); //alert('Changed value in Model & View: '  + obj.Get('type2'));
    obj.RemoveGetSet('type2');
    expect(obj.Get('type2')).toEqual(undefined); //alert('Removed Getter & Setter (should be "undefined"): ' + obj.Get('type2'));
    newVal = $.now();
    obj.Set('id3', newVal);
    expect(obj.Get('id3')).toEqual(newVal); //alert('.Get() & .Set() should still work on the property "id3": ' + obj.Get('id3'));
    obj.AddGetSet('type2');
    expect(obj.Get('type2')).toEqual(lastTypeValBeforeRemovedGetterSetter); //alert('Added Getter & Setter (should NOT be "undefined"): ' + obj.Get('type2'));
  });
  
});

describe("MVC Object: testing classes.", function() {
  var obj,
      viewId;
  
  beforeEach(function(){
    viewId = '#testArea3';
    obj = MVC.ModelView(viewId, {});
  });
  
  it("spanIsNumber should be a number", function() {
    expect(obj['spanIsNumber']).toEqual(123456);
  });
  
  it("spanIsNotNumber should not be a number", function() {
    expect(obj['spanIsNotNumber']).not.toEqual(123456);
  });
  
  
});

describe("MVC Object without object data", function() {
  var obj,
      viewId;
  
  beforeEach(function(){
    viewId = '#testAreaEmpty';
    obj = MVC.ModelView(viewId);
  });
  
  it("Object should be empty, but not null or undefined, even if not provided!", function() {
    expect(obj).not.toBe(undefined);
    expect(obj).not.toBe(null);
  });
  
  it("Model should have property added, even when not object data intially where passed (only viewId)", function() {
    expect(obj['inModel']).toEqual('foobar');
  });
  
});

  
</script>