<!--IE fixes -->
<script type="text/javascript" src="lib/json2.js"></script>
<script type="text/javascript"> if (!window.console) console = {log: function() {}}; </script>
<!--//end IE fixes -->
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script type="text/javascript" src="simple.mvc.js"></script>
<link rel="stylesheet" type="text/css" href="lib/jasmine/jasmine.css" />
<script type="text/javascript" src="lib/jasmine/jasmine.js"></script>
<script type="text/javascript" src="lib/jasmine/jasmine-html.js"></script>
<div id="testArea" style="display: none;">
  ID (input): <input class="isNumber" name="id" id="id" />
  <br />
  ID (span - updating when input ID changes): <span class="excludeFromModel" datasrc="#testArea" name="id" id="idDatabound"></span>
  <input class="excludeFromModel isNumber" datasrc="#testArea" name="id" />
  <br />
  Type: <input type="text" name="type" />
  <br />
  <input type="text" name="canIjoinTheModelEvenNotSpecified" value="I'm not specified in the model, but the view wants me to join" class="" />
  
  <input type="submit" name="submitButton" value="submitValue" />
  
</div>
<div style="display:none;">
  <h1>Outside the View</h1>
  <p>
    This input element will be databound to the property 'type' in the ViewModel 'testArea'.
    <br /> 
    <span name="type" id="typeDatabound" datasrc="#testArea"></span>
  </p>
</div>
<script>
$(function() {
  //Unit testing setup
  (function() {
    var jasmineEnv = jasmine.getEnv();
    jasmineEnv.updateInterval = 1000;

    var htmlReporter = new jasmine.HtmlReporter();

    jasmineEnv.addReporter(htmlReporter);

    jasmineEnv.specFilter = function(spec) {
      return htmlReporter.specFilter(spec);
    };

    var currentWindowOnload = window.onload;

    window.onload = function() {
      if (currentWindowOnload) {
        currentWindowOnload();
      }
      execJasmine();
    };

    function execJasmine() {
      jasmineEnv.execute();
    }

  })();
});


describe("MVC Object which reflects model changes in the DOM", function() {
  var timerCallback,
      obj,
      settings;
  beforeEach(function(){
    timerCallback = jasmine.createSpy('timerCallback');
    jasmine.Clock.useMock();
    
    settings = {
      reflectModelChangeInView:true,
      onChange: function() {
        //so something on change
      }
    };
    
    obj = new ViewModel.Create('#testArea', {
      id : 123,
      type : 'typeVal'
    }, settings);
  }); 
  
  it("obj should not be null", function() {
    expect(obj).not.toBe(null);
  });
  
  it("obj should not be undefined", function() {
    expect(obj).not.toBe(undefined);
  });
  
  it("Testing if intial value of 'id' is a Number with the value: 123", function() {
    expect(obj.id).toBe(123);
  });
  
  it("Testing if initial value of 'type' is 'typeVal'", function() {
    expect(obj.type).toBe('typeVal');
  });
  
  it("Testing if getter method is working", function() {
    //obj.type = "hello";
    var getVal = ViewModel.Get(obj, 'type');
    expect(obj.type).toBe(getVal);
  });
  
  it("Elements in the view should be threated as property of the model and therefore added to the model even not specified in the model", function() {
    var domVal = ViewModel.GetDomVal('#testArea', obj);
    expect(domVal.canIjoinTheModelEvenNotSpecified).not.toBe(null);
    expect(domVal.canIjoinTheModelEvenNotSpecified).not.toBe(undefined);
    expect(obj.canIjoinTheModelEvenNotSpecified).not.toBe(null);
    expect(obj.canIjoinTheModelEvenNotSpecified).not.toBe(undefined);
    expect(domVal.canIjoinTheModelEvenNotSpecified).toBe(obj.canIjoinTheModelEvenNotSpecified);
  });
    
  it("Changing Model property directly should not update the dom value", function() {
    var newVal = ''+Date.now();
    obj.id = newVal;
    expect(obj.id).toBe(newVal);
    var dom = ViewModel.GetDomVal('#testArea', obj);
    expect(dom.id).not.toBe(newVal);
  });
  
  it("Updating an input element should update the model accordingly", function() {
    var newVal = Date.now();
    $('#testArea #id').val(newVal).trigger('change');
    expect(obj.id).toBe(newVal);
    var dom = ViewModel.GetDomVal('#testArea', obj);
    expect(dom.id).toBe(newVal);
  });
  
  it("Updating an input element which has another element databound to it should be updated with same information", function() {
    var newVal = Date.now();
    $('#testArea #id').val(newVal).trigger('change');
    expect(obj.id).toBe(newVal);
    var dom = ViewModel.GetDomVal('#testArea', obj);
    expect(dom.id).toBe(newVal);
    //var databoundValue = $('#testArea').getSetHtml();
    var databoundValue = parseInt($('#testArea #idDatabound').text());
    //alert(JSON.stringify(databoundValue, null, 2));
    expect(databoundValue).toBe(newVal);
  });
  
  it("Updating a property in the model using ViewModel.Set() will also update the DOM value.", function() {
    var newVal = Date.now();
    ViewModel.Set(obj, 'id', newVal);
    expect(obj.id).toBe(newVal);
    var dom = ViewModel.GetDomVal('#testArea', obj);
    expect(dom.id).toBe(newVal);
  });
  
  it("View object should be equal to model object (JSON)", function() {
    var domObj = ViewModel.GetDomVal('#testArea', obj);
    settings = {settings:settings};
    $.extend(domObj, settings);
    domObj = JSON.stringify(domObj);
    var modObj = JSON.stringify(obj);
    //var a1 = jQuery.makeArray(domObj);// ($.map(domObj, function (a) { return a; })).sort();
    //var a2 = jQuery.makeArray(modObj);// ($.map(modObj, function (a) { return a; })).sort();
    //alert($.isArray(a1) + "\n" + $.isArray(a2));
    //alert(a1.sort() + "\n----\n" + a2.sort());
    //alert(domObj + "\n----\n" + modObj);
    //expect(a1.sort()).toEqual(a2.sort());
    expect(modObj).toEqual(domObj);
  });
  
  it("View object should be equal to model object (JSON) after the model has been updated", function() {
    ViewModel.Set(obj, 'id', 'foo');
    ViewModel.Set(obj, 'type', 'bar');
    var domObj = ViewModel.GetDomVal('#testArea', obj);
    settings = {settings:settings};
    $.extend(domObj, settings);
    domObj = JSON.stringify(domObj);
    var modObj = JSON.stringify(obj);
    expect(modObj).toEqual(domObj);
  });
  
  it("Should not work to get the value from a submit button", function() {
    expect(obj.submitButton).toBe(undefined);
  });
  
  it("Should work updating the value of a property using setTimeout() (simulating input change from user)", function() {
    setTimeout(function() {
      timerCallback();
    }, 3000);
    ViewModel.Set(obj, 'type', 'delay change!');
    var domVal = $('#typeDatabound').val();
    expect(domVal).toBe(obj.type);
    //alert(domVal + " =?= " + obj.type);
  });
  
});


describe("MVC Object which does NOT reflect model changes in the DOM", function() {
  var obj;
  
  beforeEach(function(){
    obj = new ViewModel.Create('#testArea', {
      id : 123,
      type : 'typeVal'
    }, {
      reflectModelChangeInView:false,
      onChange: function() {
        alert("ok");
        //var domObj = ViewModel.GetDomVal('#phone-1', phoneObj);
        //writeJsonObj(domObj, phoneObj);
      }
    });
  }); 
  
  it("obj should not be null", function() {
    expect(obj).not.toBe(null);
  });
  
  it("obj should not be undefined", function() {
    expect(obj).not.toBe(undefined);
  });
  
  it("Updating Model properties (and therefor also DOM values) using ViewModel.Set() should not work", function() {
    var newVal = Date.now();
    ViewModel.Set(obj, 'id', newVal);
    expect(obj.id).not.toBe(newVal);
    var dom = ViewModel.GetDomVal('#testArea', obj);
    expect(dom.id).not.toBe(newVal);
  });
  
});
</script>