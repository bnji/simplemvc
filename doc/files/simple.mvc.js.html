<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>simple.mvc.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Controller.html">Controller</a></li>
            
                <li><a href="..&#x2F;classes/List.html">List</a></li>
            
                <li><a href="..&#x2F;classes/ModelView.html">ModelView</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/JSON.html">JSON</a></li>
            
                <li><a href="..&#x2F;modules/MVC.html">MVC</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: simple.mvc.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;&#x2F; ==========================================================================
&#x2F;&#x2F; Project:   Simple JavaScript MVC &#x2F; MVVM
&#x2F;&#x2F; Copyright: Â©2012 Benjamin Hammer (hammerbenjamin@gmail.com)
&#x2F;&#x2F; License:   Licensed under MIT license (see LICENCE.MD)
&#x2F;&#x2F; To minify: http:&#x2F;&#x2F;localhost&#x2F;minify&#x2F;min&#x2F;?f=simplemvc&#x2F;simple.mvc.js
&#x2F;&#x2F; ==========================================================================
&#x2F;**
 * Provides the core MVC classes: Controller &amp; ModelView
 *
 * #1 Design Rule - Capitalization
 *
 * Internal methods (except the .toArray() method) have the first letter
 * capitalized. This is by design for two reasons:
 *
 *  1) JavaScript has many built in methods which already &#x27;belong&#x27; to an object
 *     so this is a good &#x27;solution&#x27; which makes it possible to use methods such
 *     as .Delete() (as .delete wouldn&#x27;t be valid in JavaScript).
 *
 * 2) To distinguish between the object&#x27;s and JS built-in and &#x27;custom&#x27; (passed
 *   with the object data when a ModelView instance is created) methods.
 *
 * #2 Design Rule - Bracket vs Dot notation
 *
 * Internet Explorer (not all) don&#x27;t like when an element&#x2F;property in an
 * object literal or array is being accessed using dot notation. Even though
 * it&#x27;s generally encouraged (e.g. www.jshint.com) to use the dot notation,
 * this would very likely break when evaluated in IE! Therefore all
 * elements&#x2F;properties should be accessed associatively with Bracket notation:
 *  obj = {foo : &#x27;bar&#x27;}; &#x2F;&#x2F;An object literal (JSON)
 *  obj = {foo : &#x27;bar&#x27;};
 *  obj[&#x27;foo&#x27;]; &#x2F;&#x2F;(OK!)
 *  obj.foo; &#x2F;&#x2F;(Breaks in IE (older versions)
 *  obj.someMethod(); &#x2F;&#x2F;(OK! - also in IE!)
 *
 *
 * Some helpful links:
 * http:&#x2F;&#x2F;viralpatel.net&#x2F;blogs&#x2F;20-top-jquery-tips-tricks-for-jquery-programmers&#x2F;
 *
 *
 * @module MVC
 * @main MVC
 *&#x2F;
var MVC = {
  &#x2F;**
   * KeyCheck
   *
   * A human way to check which key was used.
   * This is supposed to simulate a static method known from other languages such as Java.
   *
   * @method KeyCheck
   * @param {Object} e Event
   * @param {String} n Name of the key to check against (e.g. &#x27;enter&#x27;, &#x27;escape&#x27;)
   *&#x2F;
  KeyCheck : function(e, n) {
    if(e.keyCode === 13 &amp;&amp; (n === &#x27;enter&#x27; || n === &#x27;return&#x27;)) {
      return true;
    } else if(e.keyCode === 27 &amp;&amp; n === &#x27;escape&#x27;) {
      return true;
    }
    return false;
  },
  &#x2F;**
   * List
   *
   * A more human way of handling array&#x27;s in JavaScript. it extends the array
   * (currently) with two extra methods which makes it more easy and semantic
   * when adding and removing elements using .Add() and .Remove() methods
   * respectively.
   *
   * @class List
   * @param {Object} An array (is optional)
   *&#x2F;
  List : function(array) {
    &#x2F;&#x2F;If the input array is an object literal, then convert it to an array
    if(!$.isArray(array) &amp;&amp; typeof(array) === &#x27;object&#x27;) {
      &#x2F;&#x2F;console.log(&#x27;converted into array&#x27;);
      array = $.makeArray(array);
    }

    &#x2F;&#x2F;If the optional paramater &#x27;array&#x27; hasn&#x27;t been specified, then create an
    &#x2F;&#x2F;empty Array.
    if(array === undefined || array === null) {
      array = [];
    }

    &#x2F;**
     * Size
     *
     * Return the length of the array (same as array.length);
     * @return {Number} The length of the array.
     *&#x2F;
    array.Size = function() {
      return array.length;
    };

    &#x2F;**
     * Add
     *
     * Add a new element - It&#x27;s more semantic to use .Add() instead of .push().
     *
     * @method Add
     * @param {Object} An element.
     * @return {Array} The array.
     *&#x2F;
    array.Add = function(element) {
      array.push(element);
      return array;
    };

    &#x2F;**
     * Remove
     *
     * Remove an element (if found) from the array.
     *
     * @method Remove
     * @param {Object} An element.
     *&#x2F;
    array.Remove = function(element) {
      &#x2F;&#x2F;More about deleting elements from an array in JavaScript:
      &#x2F;&#x2F;http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;500606&#x2F;javascript-array-delete-elements
      &#x2F;&#x2F;indexOf breaks in IE &lt; 9!
      &#x2F;&#x2F;var i = array.indexOf(element);
      &#x2F;&#x2F;Solution:
      var i = $.inArray(element, array);
      if(i !== -1) {
        array.splice(i, 1);
        return true;
      }
      return false;
    };
    return array;
  },
  &#x2F;**
   * Controller which handles the logic, such as saving, updating or deleting
   * the object.
   *
   * For the time being the Controller class doesn&#x27;t do much more than returning
   * the same data as entered (JSON) object literal. Still this is by design, as
   * there is a possibility for the &#x27;controller&#x27; to do more than this &#x27;stuff&#x27;
   * (handling more than returning data) in the future.
   *
   *
   * @class Controller
   * @constructor
   *&#x2F;
  Controller : function(data) {
    return data;
  },
  &#x2F;**
   * ModelView creates a new object with data and settings. The data and
   * settings are (JSON) object literals and merged and returned after all the
   * internal setup is done.
   * The ModelView contains all the information about the object, which keeps
   * the View synchronized with the Model and vice versa.
   *
   * @class ModelView
   * @constructor
   *&#x2F;
  ModelView : function(viewId, $object, $settings, $methods) {
    &#x2F;&#x2F;console.log(&quot;ModelView Created...&quot;);
    
    &#x2F;&#x2F;Make sure that the object data always exists. Only require &#x27;viewId&#x27;
    if(!$object) { &#x2F;&#x2F;$object === null || $object === undefined) {
      $object = {};
    }
    else {
      $object = $.extend({}, true, $object);
    }
    
    &#x2F;&#x2F;Make sure that the object methods always exists. Only require &#x27;viewId&#x27;
    if(!$methods) { &#x2F;&#x2F;if($methods === null || $methods === undefined) {
      $methods = {};
    }
    else {
      $object = $.extend({}, true, $object, $methods);
    }
    
    &#x2F;&#x2F;Make sure that the settings always exist and with certain properties.
    if(!$settings) { &#x2F;&#x2F;if($settings === null || $settings === undefined) {
      $settings = {};
    }
    
    var datasrc = $settings[&#x27;datasrc&#x27;];
    var clone = $settings[&#x27;clone&#x27;];

    &#x2F;&#x2F;If cloning-&#x27;functionality&#x27; is specified...
    if(clone !== undefined) {
      &#x2F;&#x2F;Set the clone template to be the view id
      clone[&#x27;template&#x27;] = viewId;
      &#x2F;&#x2F;Update the view id with the new clone id
      viewId = clone[&#x27;id&#x27;];
      var viewIdNoHash = viewId.substring(1, viewId.length);
      &#x2F;&#x2F;Clone the source and update the viewId
      var withDataAndEvents = clone[&#x27;withDataAndEvents&#x27;];
      withDataAndEvents = withDataAndEvents !== undefined ? withDataAndEvents : false;
      &#x2F;&#x2F;console.log(withDataAndEvents);
      var element = $($(clone[&#x27;template&#x27;]).clone(withDataAndEvents))
                      .attr(&#x27;id&#x27;, viewIdNoHash);
      
      &#x2F;&#x2F;datasrc property to the settings, as it should be possible to create a
      &#x2F;&#x2F;ModelView without any data, but solely relies on receiving updated
      &#x2F;&#x2F;values from another view!
      &#x2F;&#x2F;If the datasrc isn&#x27;t specified, then use the viewId as datasrc.
      datasrc = datasrc !== undefined ? datasrc : viewId;
      
      &#x2F;&#x2F;Update the datasrc with the new view id
      $(element)
        &#x2F;&#x2F;.find(viewId + &#x27; li[datasrc=&quot;&quot;]&#x27;)
        .find(&#x27;[datasrc=&quot;&quot;]&#x27;)
        .attr(&#x27;datasrc&#x27;, datasrc);
      &#x2F;&#x2F;If the template originally was hidden using &#x27;display: none;&#x27; - make it visible to the user
      &#x2F;&#x2F;element.show();
      &#x2F;&#x2F;Append the copy to the target
      &#x2F;&#x2F;Execute the append callback function which normally would involve
      &#x2F;&#x2F;appending and making it visible to the user (If the template originally was hidden using &#x27;display: none;&#x27; - make it visible to the user)
      &#x2F;&#x2F;e.g.
      &#x2F;&#x2F;  Suppose we(you) in the callback function name the element &#x27;elem&#x27;:
      &#x2F;&#x2F;  $(&#x27;#someElementId&#x27;).append(elem); &#x2F;&#x2F;append it
      &#x2F;&#x2F;  $(elem).show();                   &#x2F;&#x2F;make it visible
      clone[&#x27;append&#x27;](element); &#x2F;&#x2F;execute the callback function.
    }
    
    if($settings[&#x27;viewId&#x27;] === undefined) {
      $.extend($settings, {viewId : viewId});
    }
    if($settings[&#x27;isMirror&#x27;] === undefined) {
      $.extend($settings, {isMirror : true});
    }
    if($settings[&#x27;eventUsed&#x27;] === undefined) {
      $.extend($settings, {eventUsed : &#x27;&#x27;});
    }
    if($settings[&#x27;preventDefault&#x27;] === undefined) {
      $.extend($settings, {preventDefault : true});
    }
    &#x2F;&#x2F;Maybe move these settings a little up?
  
    &#x2F;&#x2F;Attach events to the save, update, delete (more?) buttons&#x2F;submit.
    &#x2F;&#x2F;For IE we need to specify each element with the viewId individually!
    $(viewId + &#x27; button,&#x27; + viewId + &#x27; a,&#x27; + viewId + &#x27; submit,&#x27; + viewId + &#x27; i&#x27;)
      &#x2F;&#x2F;.find(&#x27;button,a,submit,i&#x27;)
      .each(function(i, e) {
        $(this)
        &#x2F;&#x2F;.attr(&#x27;id&#x27;, e.id+&#x27;_&#x27;+viewId)&#x2F;&#x2F;NoHash)
        .click(function(e) {
          &#x2F;&#x2F;$object.RunCtr($id, par);
          &#x2F;&#x2F;$object.Save();
          &#x2F;&#x2F;console.log(e.target.name);
          $object.RunCtr(e.target.name, e);
          if($settings[&#x27;settings&#x27;][&#x27;preventDefault&#x27;]) {
            e.preventDefault();
          }
        });
        &#x2F;&#x2F;console.log(i + &quot; &quot; + e.id);
      });
    
    &#x2F;&#x2F;Start: Methods
    
    &#x2F;**
     * Call the .Save() method whenever you want to save the object.
     * Notice: This is intended behaviour, but the implementation of the
     * method is up to the individual how and what is done when this method
     * is called&#x2F;executed.
     *
     * @method Save
     * @param {Object} par Provide extra parameters if needed.
     * @return {Object} The object (itself)
     *&#x2F;
    $object.Save = function(par) {
      $object.RunCtr(&#x27;Save&#x27;, par);
      return $object;
    };
    &#x2F;**
     * Call the .Update() method whenever you want to update the object.
     * Notice: This is intended behaviour, but the implementation of the
     * method is up to the individual how and what is done when this method
     * is called&#x2F;executed.
     *
     * @method Update
     * @param {Object} par Provide extra parameters if needed.
     * @return {Object} The object (itself)
     *&#x2F;
    $object.Update = function(par) {
      $object.RunCtr(&#x27;Update&#x27;, par);
      return $object;
    };
    &#x2F;**
     * Call the .Delete() method whenever you want to delete the object.
     * Notice: This is intended behaviour, but the implementation of the
     * method is up to the individual how and what is done when this method
     * is called&#x2F;executed.
     *
     * @method Delete
     * @param {Object} par Provide extra parameters if needed.
     * @return {Object} The object (itself)
     *&#x2F;
    $object.Delete = function(par) {
      $object.RunCtr(&#x27;Delete&#x27;, par);
      return $object;
    };
    
    &#x2F;**
     * Clear
     *
     * Clears a property&#x27;s value in the Model and optionally in the View if &#x27;isMirror&#x27; = true.
     *
     *
     * @method Clear
     * @return {Object} The object (itself)
     *&#x2F;
    $object.Clear = function(prop) {
      $object[prop] = &#x27;&#x27;;
      $object.Set(prop, &#x27;&#x27;);
      return $object;
    };
    
    &#x2F;**
     * Clear All
     *
     * Clears all the data in the Model and the View.
     *
     * @method ClearAll
     * @return {Object} The object (itself)
     *&#x2F;
    $object.ClearAll = function() {
      $.each($object.GetModelData(), function(prop) {
        $object.Clear(prop);
      });
      return $object;
    };
    
    &#x2F;**
     * AddGetSet
     *
     * Add getter and setter methods for a property
     *
     * Getters and Setters in JavaScript&#x2F;JScript (ECMAScript) are not an option
     * as it is hard to make it work cross-browser&#x2F;platform!
     * There is a solution here, but only down to IE9:
     * Source: http:&#x2F;&#x2F;javascriptweblog.wordpress.com&#x2F;2010&#x2F;11&#x2F;15&#x2F;extending-objects-with-javascript-getters&#x2F;
     *
     * If changes in the model properties should be reflected in the view
     * then setter and getter methods will be attached using jQuery.
     *
     * Note: Will only be used(exec.) if &#x27;isMirror&#x27; is TRUE.
     *
     * Works in IE 7+: http:&#x2F;&#x2F;jsfiddle.net&#x2F;cTJZN&#x2F;
     *
     * @method AddGetSet
     * @param {String} prop The object&#x27;s property name
     * @param {Function} onUpdate callBack function will execute, whenever
     * the get&#x2F;set event handlers bound with .bind() method are triggered.
     * @return {Object} The object (itself)
     *&#x2F;
    $object.AddGetSet = function(prop) {&#x2F;&#x2F;, onUpdate) {
      &#x2F;&#x2F;console.log(&quot;AddGetSet&quot;);
      &#x2F;&#x2F;var prop = Common.FstChrUp(prop);
      
      $($object)
        .bind(&#x27;get&#x27;+prop, function(event, ret) {
          ret[&#x27;value&#x27;] = $object[prop];
        })
        .bind(&#x27;set&#x27;+prop, function (event, newVal) {
          &#x2F;&#x2F;Replace the old value with the new value in the model
          var oldVal = $object[prop];
          &#x2F;&#x2F;Only update values if they&#x27;re changed
          if(oldVal !== newVal) {
            $object[prop] = newVal;
            
            
            &#x2F;&#x2F;alert(n + &quot;: &quot; + ov + &quot;=&gt;&quot; + nv);
            &#x2F;&#x2F;Update the view accordingly
            &#x2F;&#x2F;MVC.SetViewFromModel(viewId, $object); &#x2F;&#x2F;$(viewId).getSetHtml($object);
            $object.SetViewFromModel();
            
            &#x2F;&#x2F;Make sure that the input will have the change event triggered,
            &#x2F;&#x2F;so that the views bound to this element will also be updated.
            &#x2F;&#x2F;This is important in case the model is changed using setTimeout()
            &#x2F;&#x2F;which will update the model, then this change must simulate
            &#x2F;&#x2F;a user setting the value of the input.
            $object.TriggerEvent(prop, &#x27;change&#x27;);&#x2F;&#x2F;.TriggerEvent(prop, &#x27;keyup&#x27;);
            &#x2F;&#x2F;alert(&quot;OK&quot;);
            &#x2F;&#x2F;onUpdate(prop, oldVal, newVal);
          }
        });
        return $object;
    };
    
    &#x2F;**
     * RemoveGetSet
     *
     * Remove getter and setter methods for a property
     *
     * @method RemoveGetSet
     * @param {String} prop The object&#x27;s property name
     * @return {Object} The object (itself)
     *&#x2F;
    $object.RemoveGetSet = function(prop) {
      $($object)
        .unbind(&#x27;get&#x27;+prop)
        .unbind(&#x27;set&#x27;+prop);
        
      return $object;
    };
    
    &#x2F;**
     * Trigger Event
     *
     * Trigger an event on an input element inside the view
     *
     * @method TriggerEvent
     * @param {String} prop Property name
     * @param {String} evt Event type&#x2F;name (e.g. &#x27;keyup&#x27;)
     * @return {Object} The object (itself)
     *&#x2F;
    $object.TriggerEvent = function(prop, evt) {
      $(viewId + &#x27; :input[name=&quot;&#x27;+prop+&#x27;&quot;]&#x27;)
        .not(&#x27;.excludeFromModel&#x27;)
        .trigger(evt);
        
      return $object;
    };
    
    &#x2F;**
     * AddProperty
     *
     * Add a property to the Model
     *
     * @method AddProperty
     * @param {String} prop The property name
     * @return {Object} The object (itself)
     *&#x2F;
    $object.AddProperty = function(prop) {
      $object
        .AddEvents()
        .AddGetSet(prop)
        .TriggerEvent(prop, &#x27;keyup&#x27;);
      console.log(&quot;Added property &quot; + prop + &quot; to the Model.&quot;);
      return $object;
    };
    
    &#x2F;**
     * RemoveProperty
     *
     * Remove a property from the Model
     *
     * @method RemoveProperty
     * @param {String} prop The property name
     * @return {Object} The object (itself)
     *&#x2F;
    $object.RemoveProperty = function(prop) {
      $object.RemoveGetSet(prop);
      delete $object[prop];
      $(viewId + &#x27; :input[name=&quot;&#x27;+prop+&#x27;&quot;]&#x27;)
        .not(&#x27;.excludeFromModel&#x27;)
        .remove();
      console.log(&quot;Removed property &quot; + prop + &quot; from the Model.&quot;);
      return $object;
    };
    
    &#x2F;**
     * Set
     *
     * Notice: Must only be used if &#x27;isMirror&#x27; is TRUE.
     *
     * When you need to update a value in the Model and reflect in the View.
     *
     * @method Set
     * @param {String} prop The object&#x27;s property name
     * @param {String} value The new value to set for the property
     * @return {Object} The object (itself)
     *&#x2F;
    $object.Set = function(prop, value) {
      &#x2F;&#x2F;alert(&quot;Setting&quot;);
      &#x2F;&#x2F;console.log(&quot;Set()&quot;);
      &#x2F;&#x2F;$(obj).trigger(&#x27;set&#x27;+Common.FstChrUp(key), [val]);
      &#x2F;&#x2F;$($object).triggerHandler(&#x27;set&#x27;+prop, [value]); ?
      $($object).triggerHandler(&#x27;set&#x27;+prop, [value]);
      &#x2F;&#x2F;Update databound DOM values
      &#x2F;&#x2F;Update databound elements with datasrc if specified, otherwise with viewId.
      &#x2F;&#x2F;$object.SetDataboundDomVal(viewId, prop, value);
      $object.SetDataboundDomVal(datasrc, prop, value);
      return $object;
    };
    &#x2F;**
     * Get
     *
     * Notice: Must only be used if &#x27;isMirror&#x27; is TRUE.
     *
     * @method Get
     * @param {String} prop The object&#x27;s property name.
     * @return {Object} value The value from the object&#x27;s property.
     *&#x2F;
    $object.Get = function(prop) {
      &#x2F;&#x2F;http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;9145347&#x2F;jquery-returning-value-from-trigger
      &#x2F;&#x2F;console.log(&quot;Get()&quot;);
      var result = { value : undefined };
      &#x2F;&#x2F;$($object).triggerHandler(&#x27;get&#x27;+Common.FstChrUp(key), [result]);
      &#x2F;&#x2F;$($object).triggerHandler(&#x27;get&#x27;+prop, [result]); ?
      $($object).triggerHandler(&#x27;get&#x27;+prop, [result]);
      return result[&#x27;value&#x27;];
    };
    
    &#x2F;**
     * Has
     *
     * Checks if the Model has a given property (true) or not (false).
     *
     * @method Has
     * @param {String} prop The object&#x27;s property name
     * @return {Boolean} TRUE if the property exists. Otherwise FALSE.
     *&#x2F;
    $object.Has = function(prop) {
      if($object.Get(prop) !== undefined) {
        return true;
      }
      return false;
    };
    
    &#x2F;**
     * GetModelData
     *
     * Return&#x27;s a copy of the Model&#x27;s data without it&#x27;s functions.
     * Useful when storing the data.
     *
     * Note: As this object has all of it&#x27;s functions&#x2F;methods removed, then
     * it&#x27;s not possible to use the .toArray() (if needed for any reason) anymore.
     * Instead use $.makeArray(theObject); which is what .toArray() uses.
     *
     * @method GetModelData
     * @param {Boolean} withSettings If TRUE, then append the settings object.
     * @return {Object} A copy of the Model&#x27;s data (as JSON object literal).
     *&#x2F;
    $object.GetModelData = function(withSettings) {
      var modelObjectData = {};
        $.each($object, function(k, v) {
        &#x2F;&#x2F;Only add types which aren&#x27;t functions
        if((typeof v).toString() !== &#x27;function&#x27;) {
          &#x2F;&#x2F;Don&#x27;t add the jQuery object which is use for .Set() &amp; .Get()
          &#x2F;&#x2F;Regex test on Rubular: http:&#x2F;&#x2F;www.rubular.com&#x2F;r&#x2F;KZQH0gdHyy
          if((&#x2F;jQuery\d*&#x2F;).test(k)) {
            return true;
          }
          &#x2F;&#x2F;Only add the settings object if withSettings is TRUE.
          else if(!withSettings &amp;&amp; k === &#x27;settings&#x27;) {
            return true;
          }
          &#x2F;&#x2F;Add strings and objects (JSON literals and Arrays)
          else {
            modelObjectData[k] = v;
          }
          &#x2F;&#x2F;console.log(k + &quot; is a &quot; + typeof v);
        }
      });
      return modelObjectData;
    };
    
    &#x2F;**
     * GetDatasrcId
     *
     * Return the (view) ID of the datasource.
     *
     * @method GetDatasrcId
     * @return {Number} The (View) ID of the datasource.
     *&#x2F;
    $object.GetDatasrcId = function() {
      return $object.datasrc;
    };
    
    &#x2F;**
     * GetViewData
     *
     * Return the View data as an JSON object literal.
     *
     * @method GetViewData
     * @return {Object} The View data as JSON object
     *&#x2F;
    $object.GetViewData = function() {
      &#x2F;&#x2F;console.log(&quot;GetViewData()&quot;);
      &#x2F;&#x2F;Get the values from the View (DOM)
      return $(viewId).getSetHtml();
    };
    
    &#x2F;**
     * SetViewFromModel
     *
     * Updates the elements in the View from the Model.
     *
     * @method SetViewFromModel
     *&#x2F;
    $object.SetViewFromModel = function() {
      &#x2F;&#x2F;console.log(&quot;SetViewFromModel()&quot;);
      &#x2F;&#x2F;Set the values in the DOM
      &#x2F;&#x2F;alert(JSON.stringify($object));
      $(viewId).getSetHtml($object);
      return $object;
    };
    
    &#x2F;**
     * SetModelFromView
     *
     * Update the model and databound elements.
     *
     * This method is internally every time a &#x27;change&#x27; and &#x27;keyup&#x27; event occur
     * in form elements. This is part of the concept to always update the Model,
     * so it is synchronized with the View.
     *
     * It is possible to override the call to this method for the &#x27;keyup&#x27; event
     * if it is implemented manually in the settings. Therefore it&#x27;s important
     * to know that if overriding this event, but still want &#x27;live&#x27; updating
     * of the Model to occur, then this method must be called from the custom
     * implementation of the &#x27;keyup&#x27; event!
     *
     * @method SetModelFromView
     * @param {Boolean} updateDataboundValues TRUE | FALSE - If undefined or
     * true, databound elements inside and&#x2F;or outside the the View will also
     * get updated. If false, then they won&#x27;t.
     * @return {Object} The object (itself)
     *&#x2F;
     &#x2F;&#x2F;$object.SetModelFromView = function(updateDataboundValues) {
     $object.SetModelFromView = function() {
      &#x2F;&#x2F;console.log(&quot;SetModelFromView()&quot;);
      &#x2F;&#x2F;Get the values from the View (DOM)
      var data = $object.GetViewData();
      &#x2F;&#x2F;Update the model using the View values
      $.each(data, function(key, newVal) {
        var oldVal = $object[key];
        &#x2F;&#x2F;Only update values if they&#x27;re changed
        &#x2F;&#x2F;Check the value of oldVal (not newVal)
        var valType = typeof oldVal;
        if(oldVal !== newVal) {
          &#x2F;&#x2F;alert(&quot;Key: &quot; + key + &quot;\nOld value: &quot; + oldVal + &quot; (&quot; + typeof oldVal + &quot;)\nNew value: &quot; + newVal + &quot; (&quot; + typeof newVal + &quot;)&quot;);
          &#x2F;&#x2F;A problem arises when comparing object literals!!!
          &#x2F;&#x2F;should valType (string, number, boolean, object, undefined, function)
          &#x2F;&#x2F;be used for anything?
          &#x2F;&#x2F;When the property has not been defined in the Model, but in the View
          &#x2F;&#x2F;the value will be undefined and therefore also the type.
          &#x2F;&#x2F;In some cases this should be handled differently!
          &#x2F;&#x2F;if(valType === &#x27;string&#x27; || valType === &#x27;number&#x27; || valType === &#x27;boolean&#x27; || valType === &#x27;object&#x27; || valType === &#x27;undefined&#x27;) {
            
            &#x2F;&#x2F;alert(key + &quot;: &quot; + oldVal + &quot; changed to &quot; + newVal);
            
            &#x2F;&#x2F;Update the model with the value from DOM
            $object[key] = newVal;
            &#x2F;&#x2F;$object.Set(key, newVal);
            &#x2F;&#x2F;if(updateDataboundValues === undefined || updateDataboundValues === true) {
              &#x2F;&#x2F;alert(&quot;OK&quot;);
            &#x2F;&#x2F;}
            
          &#x2F;&#x2F;}
          &#x2F;&#x2F;else {
          &#x2F;&#x2F;  alert(&quot;Missing implementation of primitive types in SetModelFromView() method for type: &quot; + valType);
          &#x2F;&#x2F;}
        }
        &#x2F;&#x2F;Update databound DOM values even
        &#x2F;&#x2F;When setting the values on .init() the databound items should ofcourse
        &#x2F;&#x2F;get updated even if the model data is same as in the view.
        $object.SetDataboundDomVal(viewId, key, newVal);
      });
      &#x2F;&#x2F;Return the values in JSON format
      &#x2F;&#x2F;return data;
      return $object;
    };
    
    &#x2F;**
     * SetDataboundDomVal
     *
     * Update the databound elements inside or outside the View.
     *
     * @method SetDataboundDomVal
     * @param {String} datasrc A viewId.
     * @param {String} name An element&#x27;s name.
     * @param {String} value A new value.
     * @return {Object} The object (itself)
     *&#x2F;
    $object.SetDataboundDomVal = function(datasrc, name, value) {
      &#x2F;&#x2F;console.log(&quot;SetDataboundDomVal()&quot;);
      &#x2F;&#x2F;The following works fine, except it breaks in IE&lt;9!!!
      &#x2F;&#x2F;$(&#x27;[datasrc=&#x27;+datasrc+&#x27;][name=&#x27;+name+&#x27;]&#x27;).text(value).val(value);
      &#x2F;&#x2F;This works though:
      &#x2F;&#x2F;console.log(counter + &quot; - datasrc: &quot; + datasrc + &quot; - name: &quot; + name + &quot; - value: &quot; + value);
      $(&#x27;div[datasrc|=&#x27;+datasrc+&#x27;][name|=&#x27;+name+&#x27;],p[datasrc|=&#x27;+datasrc+&#x27;][name|=&#x27;+name+&#x27;],span[datasrc|=&#x27;+datasrc+&#x27;][name|=&#x27;+name+&#x27;]&#x27;).text(value);
      $(&#x27;input[datasrc|=&#x27;+datasrc+&#x27;][name|=&#x27;+name+&#x27;]&#x27;).val(value);
      &#x2F;&#x2F;counter++;
      return $object;
    };
    
    &#x2F;**
     * RunEvent
     *
     * Trigger an event if specified in the settings.
     *
     * @method RunEvent
     * @param {String} event The eventName to trigger&#x2F;execute.
     * @return {Object} The object (itself)
     *&#x2F;
    $object.RunEvent = function(event) {
      &#x2F;&#x2F;alert(event.target.name);
      var type = event.type;
      if(type === undefined) {
        type = event;
      }
      if(event === undefined) {
        &#x2F;&#x2F;console.log(&#x27;event &quot;e&quot; is undefined!&#x27;);
        return;
      }
      if($.trim(event.target.name).length &gt; 0) {
        if($settings[&#x27;settings&#x27;][type] !== undefined &amp;&amp; $settings[&#x27;settings&#x27;][type] !== null) {
          $settings[&#x27;settings&#x27;][&#x27;eventUsed&#x27;] = type;
          &#x2F;&#x2F;console.log(type);
          $settings[&#x27;settings&#x27;][type](event, event.target.name, event.target.value);
        }
      } else {
        console.log(&quot;source element has no name attribute assigned (required!)&quot;);
      }
      return $object;
    };
    
    &#x2F;**
     * RunCtr
     *
     * Execute a method in the controller.
     *
     * @method RunCtr
     * @param {String} method The methods name specified in the controller.
     * @param {Object} par If needed you can provide optional parameters.
     * @return {Object} The object (itself)
     *&#x2F;
    $object.RunCtr = function(method, par) {
      var exec = $object[&#x27;settings&#x27;][&#x27;controller&#x27;][method];
      if(exec !== undefined &amp;&amp; exec !== null) {
        exec(par);
      } else {
        console.log(&#x27;Missing &#x27; + method + &#x27;() method!&#x27;);
      }
      return $object;
    };
    
    &#x2F;**
     * toArray
     *
     * Convert the object to a real Array.
     *
     * @method toArray
     * @return {Array} The object converted into a real Array.
     *&#x2F;
    $object.toArray = function() {
      return $.makeArray($object);
    };
    
    &#x2F;**
     * GetViewId
     *
     * Get the ID of the View
     *
     * @method GetViewId
     * @return {String} The View ID
     *&#x2F;
    $object.GetViewId = function() {
      return $object[&#x27;settings&#x27;][&#x27;viewId&#x27;];
    };
    
    &#x2F;**
     * Find
     *
     * Find and return one or many element&#x2F;s within the View using a (id or class) selector.
     *
     * If the elemenet is not found an empty array is returned.
     *
     * @method Find
     * @return {Array} An element from the View.
     *&#x2F;
    $object.Find = function(selector) {
      return $($object.GetViewId() + &#x27; &#x27; + selector);
    };
    
    &#x2F;**
     * AddEvents
     *
     * Add events to the object&#x27;s input fields
     *
     * @method AddEvents
     * @return {Object} The object
     *&#x2F;
    $object.AddEvents = function() {
      &#x2F;&#x2F;Update the model view, whenever a change occurs
      $(viewId + &#x27; :input&#x27;)
        .not(&#x27;.excludeFromModel&#x27;)
        .focus(function(e){
          &#x2F;&#x2F;http:&#x2F;&#x2F;jsfiddle.net&#x2F;PKVVP&#x2F;
          $object.RunEvent(e);
        })
        .blur(function(e) {
          $object.RunEvent(e);
        })
        .change(function(e){
          &#x2F;&#x2F;Update the model and also the databound elements
          &#x2F;&#x2F;MVC.SetModelFromView(viewId, $object); &#x2F;&#x2F;Always do this (core concept!)
          $object.SetModelFromView(); &#x2F;&#x2F;Always do this (core concept!)
          $object.RunEvent(e);
        })
        .select(function(e) {
          $object.RunEvent(e);
        })
        .submit(function(e){
          $object.RunEvent(e);
        })
        &#x2F;**
         * keyup event
         *
         * It&#x27;s important to know that when overriding this event,
         * but still want &#x27;live&#x27; updating of the Model to occur,
         * then this method must be called from the custom implementation
         * of the &#x27;keyup&#x27; event!
         *
         * @event keyup ...
         *
         *&#x2F;
        .keyup(function(e){
          &#x2F;&#x2F;console.log(&quot;keyup&quot;);
          &#x2F;&#x2F;If the &#x27;keyup&#x27; event hasn&#x27;t been specified in the settings, then
          &#x2F;&#x2F;by default update the Model and databound values using the
          &#x2F;&#x2F;SetModelFromView() method
          if($settings[&#x27;settings&#x27;][&#x27;keyup&#x27;] === undefined) {
            &#x2F;&#x2F;$object.SetDataboundDomVal(viewId, e.target.name, e.target.value);
            $object.SetModelFromView();
          }
          $object.RunEvent(e); &#x2F;&#x2F;e should euqal &#x27;change&#x27;
          &#x2F;*var n = $(this).attr(&#x27;name&#x27;);
          var v = $(this).val();
          MVC.SetDataboundDomVal(viewId, n, v);*&#x2F;
        })
        .keypress(function(e) {
          $object.RunEvent(e);
        })
        .keydown(function(e) {
          $object.RunEvent(e);
        });
        return $object;
    };
    
    &#x2F;&#x2F; END: Internal methods
    
    &#x2F;&#x2F; START: Setup
    
    &#x2F;&#x2F;Set the DOM values from the Model
    &#x2F;&#x2F;MVC.SetViewFromModel(viewId, $object);
    $object.SetViewFromModel();
    &#x2F;&#x2F;Initialize the View with the Model data if they aren&#x27;t specified in the Model
    &#x2F;&#x2F;MVC.SetModelFromView(viewId, $object);
    $object.SetModelFromView();
    
    &#x2F;&#x2F;If Model property changes should be reflected&#x2F;displayed in the View:
    &#x2F;&#x2F;Loop throught the properties within the object and attach events using the
    &#x2F;&#x2F;jQuery .bind() method. Whenever the user wants to update a value it can
    &#x2F;&#x2F;be achieved using the .trigger() method, which is implemented in the
    &#x2F;&#x2F;MVC.Set() and MVC.Get() methods.
    &#x2F;&#x2F;Note: Changing the Model&#x27;s properties directly won&#x27;t update the view.
    if($settings[&#x27;isMirror&#x27;]) {
      &#x2F;&#x2F;alert(&quot;reflect on&quot;);
      &#x2F;&#x2F;Loop throught the object&#x27;s properties
      $.each($object, function(k,v) {
        &#x2F;&#x2F;alert(k + &quot; : &quot; + v);
        &#x2F;&#x2F;var pars = MVC.GetViewData(viewId);
        &#x2F;&#x2F;Add the Getter and Setter methods
        &#x2F;&#x2F;n: name, ov: old value, nv: new value
        &#x2F;&#x2F;MVC.AddGetSet($object, k, function(n, ov, nv) {
        $object.AddGetSet(k);&#x2F;*, function(n, ov, nv) {
          &#x2F;&#x2F;alert(n + &quot;: &quot; + ov + &quot;=&gt;&quot; + nv);
          &#x2F;&#x2F;Update the view accordingly
          &#x2F;&#x2F;MVC.SetViewFromModel(viewId, $object); &#x2F;&#x2F;$(viewId).getSetHtml($object);
          $object.SetViewFromModel();
          
          &#x2F;&#x2F;Make sure that the input will have the change event triggered,
          &#x2F;&#x2F;so that the views bound to this element will also be updated.
          &#x2F;&#x2F;This is important in case the model is changed using setTimeout()
          &#x2F;&#x2F;which will update the model, then this change must simulate
          &#x2F;&#x2F;a user setting the value of the input.
          $(&#x27;:input[name=&#x27;+n+&#x27;]&#x27;).not(&#x27;.excludeFromModel&#x27;).trigger(&#x27;change&#x27;);
        });*&#x2F;
      });
    }
    
    if($settings[&#x27;autoSaveInterval&#x27;] &gt; 0) {
      $settings[&#x27;eventUsed&#x27;] = &#x27;&quot;autoSave&quot;&#x27;;
      setInterval(function() {
        $object.Save();
      }, $settings[&#x27;autoSaveInterval&#x27;]);
    }
    
    $object.AddEvents();

    &#x2F;&#x2F;Add the settings to the Model object
    $settings = { settings : $settings };
    &#x2F;&#x2F;$.extend($object, $settings);
    &#x2F;&#x2F;Add the data to the Model object
    &#x2F;&#x2F;$data = { data : $data };
    $.extend($object, $settings);
    &#x2F;&#x2F;alert(JSON.stringify($object, null, 2));
    
    
    &#x2F;**
     * To keep the code which belongs to the object, but normally would be
     * placed after object instantiation, we isntead want to place it inside
     * the .init() method, which gets executed 1ms after the object has been
     * created.
     *
     * Why we use setTimeout: read below...
     *
     * In some cases the user wants to call the object itself like this:
     *
     *
     * &#x2F;&#x2F;Create a new object
     * obj = MVC.ModelView(&#x27;#viewId&#x27;, {
     *   &#x2F;&#x2F;Data:
     *   foo : &#x27;bar&#x27;,
     *   &#x2F;&#x2F;Method
     *   aCustomMethod : function() {
     *    &#x2F;&#x2F;does something
     *   }
     *   init : function() {
     *     &#x2F;&#x2F;All methods and other &#x27;stuff&#x27; placed inside the .init() method
     *     &#x2F;&#x2F;gets executed immediately after the object has been created (setup).
     *     &#x2F;&#x2F;Therefore it&#x27;s important (and necessary) to use setTimeout, as the
     *     &#x2F;&#x2F;object actually hasn&#x27;t been created yet. So we set it to 1 ms!
     *     obj.aCustomMethod();
     *   }
     * }
     * });
     *&#x2F;
    var init = $object[&#x27;init&#x27;];
    &#x2F;&#x2F;Do not run the .init() method if it is undefined or null!
    if(init !== undefined &amp;&amp; init !== null) {
      setTimeout(function() {
        init();
      }, 1);
    }
    return $object;
  }
};

&#x2F;**
 * Get or set HTML (DOM) values
 *
 * Inspired by formParams: http:&#x2F;&#x2F;jquerypp.com&#x2F;#formparams
 *
 * @param {Object} jQuery
 *&#x2F;
(function( $ ) {
  $.fn.extend({
    getSetHtml: function( params ) {
      if(params !== undefined) {
        return this.setValues(params);
      }
      else {
        return this.getValues();
      }
    },
    getInputElements : function(target) {
      return target.find(&#x27;input,select,textarea&#x27;).filter(&#x27;:not(.excludeFromModel)&#x27;);
    },
    getElementKey : function(element) {
      var key = $(element).attr(&quot;datafld&quot;);
      if(key === undefined) {
        key = $(element).attr(&quot;id&quot;);
      }
      return key;
      &#x2F;&#x2F;return $(element).attr(&quot;datafld&quot;) ? undefined : $(element).attr(&quot;id&quot;);
    },
    getDivElements : function(target) {
      return target.find(&#x27;p,span,div&#x27;).filter(&#x27;:not(.excludeFromModel)&#x27;);
    },
    setValues : function(params) {
      &#x2F;&#x2F;console.log(&#x27;setValues called!&#x27;);
      &#x2F;&#x2F;console.log(this.getDivElements(this));
      &#x2F;&#x2F;Set the values for  &#x27;p&#x27;, &#x27;div&#x27; and &#x27;span&#x27; elements
      var $this = this;
      $this.getDivElements(this).each(function() {
        var key = $this.getElementKey(this);
        if(key === undefined) {
          return;
        }
        &#x2F;&#x2F;alert(key);
        var value = params[key];
        &#x2F;&#x2F;alert(key + &quot; = &quot; + value);
        &#x2F;&#x2F;console.log(value);
        $(this).html(value);
        &#x2F;&#x2F;var toReplace = $.trim($(this).text());
        &#x2F;&#x2F;alert(toReplace);
      });
      
      $this.getInputElements(this).each(function(){
        var value = params[ $(this).attr(&quot;name&quot;) ], $this;
        &#x2F;&#x2F; Don&#x27;t do all this work if there&#x27;s no value
        if ( value !== undefined) {
          $this = $(this);
          
          if ( $this.is(&quot;:radio&quot;) ) {
            if ( $this.val() === value ) {
              $this.attr(&quot;checked&quot;, true);
            }
          } else if ( $this.is(&quot;:checkbox&quot;) ) {
            &#x2F;&#x2F; Convert single value to an array to reduce
            &#x2F;&#x2F; complexity
            if(value) {
              $this.attr(&quot;checked&quot;, true);
            }
            else {
              value = $.isArray( value ) ? value : [value];
              if ( $.inArray( $this.val(), value ) &gt; -1) {
                $this.attr(&quot;checked&quot;, true);
              }
            }
            $this.val( value );
          } else {
            $this.val( value );
          }
        }
      });
      
    },
    getValues : function() {
      var data = {},
          formData = {};
      var $this = this;
      $this.getInputElements(this).each(function() {
        var elm = $(this);
        var type = elm.attr(&#x27;type&#x27;),
            name = elm.attr(&#x27;name&#x27;),
            value = elm.val();
        if(type === &#x27;submit&#x27; || !name) {
          return;
        }
        
        &#x2F;&#x2F;console.log(&quot;type: &quot; + type + &quot; - name: &quot; + name + &quot; - value: &quot; + value);
        if(elm.hasClass(&#x27;isNumber&#x27;)) {
          value = parseInt(value, null);
        }
        
        if(elm.is(&#x27;:checkbox&#x27;)) {
          value = false;
          if(elm.attr(&#x27;checked&#x27;)) {
            value = true;
          }
          formData[name] = value;
        }
        else if(elm.is(&#x27;:radio&#x27;)) {
          if(elm.attr(&#x27;checked&#x27;)) {
            formData[name] = value;
          }
        }
        else {
          formData[name] = value;
        }
      });
      
      $this.getDivElements(this).each(function() {
        var elem = $(this);
        var value = elem.text();
        if(value !== undefined) {
          var key = $this.getElementKey(this);
          if(key === undefined) {
            return;
          }
          if(elem.hasClass(&#x27;isNumber&#x27;)) {
            value = parseInt(value, null);
          }
          &#x2F;&#x2F;alert(key + &quot; = &quot; + value);
          data[key] = value;
        }
      });
      $.extend(data, formData);
      &#x2F;&#x2F;alert(CMN.JSON.stringify(data, null, 2));
      return data;
    }
  });
})(jQuery);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
